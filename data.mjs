
        const data = {
            "posts": [{"title":"Getting current working directory in Node.js with process.cwd()","tags":[{"name":"nodejs","id":"nodejs-413757"},{"name":"javascript","id":"javascript-336084"}],"date":"2023-05-31 16:32","description":"process.cwd() is a method in the Node.js process module that returns the current working directory of the Node.js process.","slug":"current-working-directory-in-nodejs-with-processcwd","id":"getting-current-working-directory-in-nodejs-with-processcwd-394387","content":"<h2>process.cwd()</h2>\n<p><code>process.cwd()</code> is a method in the Node.js process module that returns the current working directory of the Node.js process. The method does not take any parameters.</p>\n<p>The difference between <code>process.cwd()</code> and <code>__dirname</code> is that <code>process.cwd()</code> returns the current working directory of the process, while <code>__dirname</code> returns the directory name of the current module or file. <code>__dirname</code> is a property of the module, whereas <code>process.cwd()</code> is a method of the global <code>process</code> object.</p>\n<p>Here are some use cases and examples of how to use <code>process.cwd()</code>:</p>\n<ul>\n<li>To print the current working directory of the Node.js process, you can simply call <code>process.cwd()</code>:</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(process.<span class=\"hljs-title function_\">cwd</span>());</code></pre>\n<ul>\n<li>To change the current working directory of the Node.js process, you can use the <code>process.chdir(directory)</code> method. This method changes the current working directory to <code>directory</code>.</li>\n</ul>\n<pre><code class=\"hljs language-javascript\">process.<span class=\"hljs-title function_\">chdir</span>(<span class=\"hljs-string\">'/tmp'</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(process.<span class=\"hljs-title function_\">cwd</span>());</code></pre>\n<ul>\n<li>You can use <code>process.cwd()</code> to create file paths relative to the current working directory of the Node.js process. For example:</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'path'</span>);\n\n<span class=\"hljs-keyword\">const</span> filePath = path.<span class=\"hljs-title function_\">join</span>(process.<span class=\"hljs-title function_\">cwd</span>(), <span class=\"hljs-string\">'data'</span>, <span class=\"hljs-string\">'file.txt'</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(filePath);</code></pre>\n<p>This will print the file path <code>/path/to/current/working/directory/data/file.txt</code>.</p>\n<p>Note that <code>process.cwd()</code> returns the current working directory of the Node.js process, which may not necessarily be the same as the directory where the Node.js script is located. To get the directory where the script is located, you can use <code>__dirname</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(__dirname);</code></pre>\n<p>This will print the directory where the script is located.</p>\n<p>Overall, <code>process.cwd()</code> is a useful method for working with file paths and changing the current working directory of the Node.js process.</p>\n<p>Sources:</p>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/node-js-process-cwd-method/\">GeeksforGeeks</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9874382/whats-the-difference-between-process-cwd-vs-dirname\">Stack Overflow</a></li>\n<li><a href=\"https://blog.logrocket.com/understanding-using-globs-node-js/\">LogRocket</a></li>\n<li><a href=\"https://www.baeldung.com/linux/find-working-directory-of-running-process\">Baeldung</a></li>\n</ul>\n"},{"title":"Data Fetching with getStaticProps in Next.js","tags":[{"name":"nextjs","id":"nextjs-368925"}],"date":"2023-05-31 14:20","description":"","slug":"data-fetching-with-getstaticprops-in-nextjs","id":"data-fetching-with-getstaticprops-in-nextjs-618257","content":"<h1>getStaticProps</h1>\n<p>If you export a function called <code>getStaticProps</code> (Static Site Generation) from a page, Next.js will pre-render this page at build time using the props returned by <code>getStaticProps</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getStaticProps</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.github.com/repos/vercel/next.js'</span>);\n  <span class=\"hljs-keyword\">const</span> repo = <span class=\"hljs-keyword\">await</span> res.<span class=\"hljs-title function_\">json</span>();\n  <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">props</span>: { repo } };\n};\n \n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Page</span>(<span class=\"hljs-params\">{ repo }</span>) {\n  <span class=\"hljs-keyword\">return</span> repo.<span class=\"hljs-property\">stargazers_count</span>;\n}</code></pre>\n<h2>When should I use getStaticProps?</h2>\n<p>You should use <code>getStaticProps</code> if:</p>\n<ul>\n<li>The data required to render the page is available at build time ahead of a user’s request.</li>\n<li>The data comes from a headless CMS.</li>\n<li>The data can be publicly cached (not user-specific). This condition can be bypassed in certain specific situation by using a Middleware to rewrite the path.</li>\n<li>The page must be pre-rendered (for SEO) and be very fast — <code>getStaticProps</code> generates HTML and JSON files, both of which can be cached by a CDN for performance.</li>\n</ul>\n<h2>When does getStaticProps run?</h2>\n<p><code>getStaticProps</code> always runs on the server and never on the client.</p>\n<ul>\n<li>\n<p><code>getStaticProps</code> always runs during next build</p>\n</li>\n<li>\n<p><code>getStaticProps</code> runs in the background when using <code>fallback: true</code></p>\n</li>\n<li>\n<p><code>getStaticProps</code> is called before initial render when using <code>fallback: blocking</code>\n<code>getStaticProps</code> runs in the background when using <code>revalidate</code>\n<code>getStaticProps</code> runs on-demand in the background when using <code>revalidate()</code></p>\n</li>\n</ul>\n<p>When combined with <strong>Incremental Static Regeneration</strong>, <code>getStaticProps</code> will run in the background while the stale page is being revalidated, and the fresh page served to the browser.</p>\n<p><code>getStaticProps</code> does not have access to the incoming request (such as query parameters or HTTP headers) as it generates static HTML. If you need access to the request for your page, consider using Middleware in addition to <code>getStaticProps</code>.</p>\n<h2>Statically generates both HTML and JSON</h2>\n<p>When a page with <code>getStaticProps</code> is pre-rendered at build time, in addition to the page HTML file, Next.js generates a JSON file holding the result of running getStaticProps.</p>\n<p>This JSON file will be used in client-side routing through <code>next/link</code> or <code>next/router</code>. When you navigate to a page that’s pre-rendered using <code>getStaticProps</code>, Next.js fetches this JSON file (pre-computed at build time) and uses it as the props for the page component. This means that client-side page transitions will not call <code>getStaticProps</code> as only the exported JSON is used.</p>\n<p>When using <strong>Incremental Static Generation</strong>, <code>getStaticProps</code> will be executed in the background to generate the JSON needed for client-side navigation. You may see this in the form of multiple requests being made for the same page, however, this is intended and has no impact on end-user performance.</p>\n<h2>Where can I use getStaticProps</h2>\n<p><code>getStaticProps</code> can only be exported from a page. You cannot export it from non-page files, <code>_app</code>, <code>_document</code>, or <code>_error</code>.</p>\n<p>One of the reasons for this restriction is that React needs to have all the required data before the page is rendered.</p>\n<p>Also, you must use export <code>getStaticProps</code> as a standalone function — it will not work if you add <code>getStaticProps</code> as a property of the page component.</p>\n<h2>Runs on every request in development</h2>\n<p>In development (next dev), getStaticProps will be called on every request.</p>\n"},{"title":"Defining Routes in Next.js App Router","date":"2023-06-02T00:00:00.000Z","tags":[{"name":"nextjs","id":"nextjs-168580"},{"name":"app-router","id":"app-router-775963"}],"description":"","slug":"defining-routes-in-nextjs-app-router","id":"defining-routes-in-nextjs-app-router-861381","content":"<p>This page will guide you through how to define and organize routes in your Next.js application.</p>\n<h2>Creating Routes</h2>\n<p>Next.js uses a file-system based router where <strong>folders</strong> are used to define routes.</p>\n<p>Each folder represents a <a href=\"https://nextjs.org/docs/app/building-your-application/routing#route-segments\"><strong>route</strong> segment</a> that maps to a <strong>URL</strong> segment. To create a <a href=\"https://nextjs.org/docs/app/building-your-application/routing#nested-routes\">nested route</a>, you can nest folders inside each other.</p>\n<p><img src=\"https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Froute-segments-to-path-segments.png&#x26;w=1920&#x26;q=75\" alt=\"\"></p>\n<p>A special <a href=\"https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#pages\"><code>page.js</code> file</a> is used to make route segments publicly accessible.</p>\n<p><img src=\"https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fdefining-routes.png&#x26;w=1920&#x26;q=75\" alt=\"\"></p>\n<p>In this example, the <code>/dashboard/analytics</code> URL path is <em>not</em> publicly accessible because it does not have a corresponding <code>page.js</code> file. This folder could be used to store components, stylesheets, images, or other colocated files.</p>\n<h2>Creating UI</h2>\n<p><a href=\"https://nextjs.org/docs/app/building-your-application/routing#file-conventions\">Special file conventions</a> are used to create UI for each route segment. The most common are <a href=\"https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#pages\">pages</a> to show UI unique to a route, and <a href=\"https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#layouts\">layouts</a> to show UI that is shared across multiple routes.</p>\n<p>For example, to create your first page, add a <code>page.js</code> file inside the <code>app</code> directory and export a React component:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Page</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>Hello, Next.js!<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span></span>;\n}</code></pre>\n"},{"title":"Difference between CommonJS and ES modules","date":null,"description":"","slug":"difference-between-commonjs-and-es-modules","id":"difference-between-commonjs-and-es-modules-864193","tags":[],"content":"<p>CommonJS and ES modules are two different ways of importing modules in JavaScript.</p>\n<p>CommonJS is a module system used Node.js for importing and exporting modules. It uses the <code>require()</code> function for importing modules and the <code>module.exports</code> or <code>exports</code> object for exporting modules.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"express\"</span>)</code></pre>\n<p>ES modules, also knows as ECMAScript modules, is the official standard for JavaScript modules. It used the <code>import</code> keyword for importing modules and the <code>export</code> keyword for exporting modules.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> express <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'express'</span></code></pre>\n<p>In Node.js, the <code>import</code> statement can only be used when the file containing the code is being executed in a module environment, which is enabled by default when the file is run using the <code>--experiment-modules</code> flag, or by adding <code>\"type\" : \"module\"</code> to package.json.</p>\n<pre><code class=\"hljs language-json\">...\n<span class=\"hljs-attr\">\"main\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"index.js\"</span><span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-attr\">\"type\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"module\"</span><span class=\"hljs-punctuation\">,</span>\n...</code></pre>\n<p>One main difference between the two is that CommonJS modules are executed immendiately, while ES modules are executed only when they are imported. This means that if a CommonJS module is imported multiple times, it will execute multiple times, while an ES module will execute only once. Additionally, CommonJS modules use a global <code>require()</code> function, while ES modules use a more explicit import statement, making the dependencies of a module more clear.</p>\n<p>Another difference is that CommonJS modules are synchronous, which means that the imported module is guaranteed to be fully loaded and executed before the next line of code is executed. ES modules, on the other hand, are asynchronous, which means that the imported module may not be fully loaded and executed before the next line of code is executed.</p>\n<p>It is worth noting that in browser, you can use <code>&#x3C;script type='module'></code> to import ES modules and <code>&#x3C;script type=\"text/javascript\" nomodule></code> to import CommonJS modules.</p>\n"},{"tags":[{"name":"flask","id":"flask-893185"}],"title":"Custom Decorators in Flask","date":null,"description":"","slug":"custom-decorators-in-flask","id":"custom-decorators-in-flask-389281","content":"<p>A decorator modifies the behavior of a function or a route by wrapping it in another function that adds some extra functionality.</p>\n<p>The decorator is a Python function that takes a view function as an argument and returns a new function that wraps the original view function. When the Flask app receives a request for the route associated with the decorated view function, Flask calls the wrapper function instead of the original view function. The wrapper function then performs some extra work before or after calling the original view function.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> flask <span class=\"hljs-keyword\">import</span> Flask, request, jsonify\napp = Flask(__name__)\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">require_api_key</span>(<span class=\"hljs-params\">view_function</span>)\n\t<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">decorated_function</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n\t\t<span class=\"hljs-keyword\">if</span> request.headers.get(<span class=\"hljs-string\">\"X-API-KEY\"</span>) <span class=\"hljs-keyword\">and</span> request.headers.get(<span class=\"hljs-string\">\"X-API-KEY\"</span>) == <span class=\"hljs-string\">\"my-secret-key\"</span>:\n\t\t\t<span class=\"hljs-keyword\">return</span> view_function(*args, **kwargs)\n\t\t<span class=\"hljs-keyword\">else</span>:\n\t\t\t<span class=\"hljs-keyword\">return</span> jsonify({<span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-string\">\"API Key is missing or invalid\"</span>}), <span class=\"hljs-number\">401</span>\n\t<span class=\"hljs-keyword\">return</span> decorated_function\n\n<span class=\"hljs-meta\">@app.route(<span class=\"hljs-params\"><span class=\"hljs-string\">\"/protected\"</span></span>)</span>\n<span class=\"hljs-meta\">@require_api_key</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">protected</span>():\n\t<span class=\"hljs-keyword\">return</span> jsonify({<span class=\"hljs-string\">\"message\"</span> : <span class=\"hljs-string\">\"This is a protected route\"</span>})\n\t\t</code></pre>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">my_decorator</span>(<span class=\"hljs-params\">view_function</span>):\n\t<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper_function</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n\t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Args\"</span>, args)\n\t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Kwargs\"</span> : kwargs)\n\t\t<span class=\"hljs-keyword\">return</span> view_function(*args, **kwargs)\n\t<span class=\"hljs-keyword\">return</span> wrapper_function\n\n<span class=\"hljs-meta\">@app.route(<span class=\"hljs-params\"><span class=\"hljs-string\">\"/&#x3C;arg1>/&#x3C;arg2>\"</span></span>)</span>\n<span class=\"hljs-meta\">@my_decorator</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">my_view_function</span>(<span class=\"hljs-params\">arg1, arg2</span>):\n\t<span class=\"hljs-comment\"># View function logic here</span></code></pre>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">decoartor</span>(<span class=\"hljs-params\">view_function</span>)\n\t<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper_function</span>():\n\t\t<span class=\"hljs-comment\"># Perform some extra work here</span>\n\t\tresponse = view_function()\n\t\t<span class=\"hljs-comment\"># Perform some extra work here</span>\n\t\t<span class=\"hljs-keyword\">return</span> response\n\t<span class=\"hljs-keyword\">return</span> wrapper_function    </code></pre>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">my_decorator</span>(<span class=\"hljs-params\">func</span>):\n<span class=\"hljs-meta\">    @wraps(<span class=\"hljs-params\">func</span>)</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">wrapper</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Before the function is called.\"</span>)\n        result = func(*args, **kwargs)\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"After the function is called.\"</span>)\n        <span class=\"hljs-keyword\">return</span> result\n    <span class=\"hljs-keyword\">return</span> wrapper\n\n<span class=\"hljs-meta\">@my_decorator</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">my_function</span>():\n    <span class=\"hljs-string\">\"\"\"This is the docstring for my_function.\"\"\"</span>\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello, world!\"</span>)\n\nmy_function()\n</code></pre>\n<p>The <code>@wraps(func)</code> is used to presever the original function's metadata, including its docstring. Without the <code>wraps</code> decorator, the docstring of the original function would be replaced with the docstring of the <code>wrapper</code> function.</p>\n"},{"tags":[{"name":"flask","id":"flask-213988"}],"title":"Flask Authentication Using JSON Web Tokens","date":null,"description":"","slug":"flask-authentication-using-json-web-tokens","id":"flask-authentication-using-json-web-tokens-232140","content":"<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> flask <span class=\"hljs-keyword\">import</span> Flask, jsonify, request, make_response\n<span class=\"hljs-keyword\">import</span> jwt\n<span class=\"hljs-keyword\">import</span> datetime\n<span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\napp = Flask(_name_)\n\napp.config[<span class=\"hljs-string\">'SECREY_KEY'</span>] = <span class=\"hljs-string\">\"thisisthesecretkey\"</span>\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">token_required</span>(<span class=\"hljs-params\">f</span>):\n<span class=\"hljs-meta\">\t@wraps(<span class=\"hljs-params\">f</span>)</span>\n\t<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">decorated</span>(<span class=\"hljs-params\">*args, **kwargs</span>):\n\t\ttoken = request.args.get(<span class=\"hljs-string\">\"token\"</span>)\n\t\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> token:\n\t\t\t<span class=\"hljs-keyword\">return</span> jsonify({<span class=\"hljs-string\">\"message\"</span> : <span class=\"hljs-string\">\"Token is missing\"</span>}), <span class=\"hljs-number\">403</span>\n\t\t<span class=\"hljs-keyword\">try</span>:\n\t\t\tdata = jwt.decode(token, app.config[<span class=\"hljs-string\">\"SECRET_TOKEN\"</span>])\n\t\texecpt:\n\t\t\t<span class=\"hljs-keyword\">return</span> jsonify({<span class=\"hljs-string\">\"message\"</span> : <span class=\"hljs-string\">\"Token is invalid\"</span>}), <span class=\"hljs-number\">403</span>\n\t<span class=\"hljs-keyword\">return</span> decorated\n\n\n<span class=\"hljs-meta\">@app.route(<span class=\"hljs-params\"><span class=\"hljs-string\">\"/unprotected\"</span></span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">unprotected</span>():\n\t<span class=\"hljs-keyword\">return</span> jsonify({<span class=\"hljs-string\">\"message\"</span> : <span class=\"hljs-string\">\"Anyone can view this\"</span>})\n\n<span class=\"hljs-meta\">@app.route(<span class=\"hljs-params\"><span class=\"hljs-string\">\"/protected\"</span></span>)</span>\n<span class=\"hljs-meta\">@token_required</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">protected</span>():\n\t<span class=\"hljs-keyword\">return</span> jsonify({<span class=\"hljs-string\">\"message\"</span> : <span class=\"hljs-string\">\"This is only available for people with valid tokens   \"</span>})\n\n<span class=\"hljs-meta\">@app.route(<span class=\"hljs-params\"><span class=\"hljs-string\">\"/login\"</span></span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">login</span>():\n\tauth = request.authorization\n\t<span class=\"hljs-keyword\">if</span> auth <span class=\"hljs-keyword\">and</span> auth.password == <span class=\"hljs-string\">\"password\"</span>:\n\t\ttoken = jwt.encode({<span class=\"hljs-string\">\"user\"</span> : auth.username, <span class=\"hljs-string\">\"exp\"</span> : datetime.datetime.utcnow() + datetimne.timedelta(minutes=<span class=\"hljs-number\">30</span>)}, app.config[<span class=\"hljs-string\">\"SECRET_KEY\"</span>])\n\t\t<span class=\"hljs-keyword\">return</span> jsonify({<span class=\"hljs-string\">\"token\"</span> : token.decode(<span class=\"hljs-string\">\"UTF-8\"</span>)})\n\t<span class=\"hljs-keyword\">return</span> make_response(<span class=\"hljs-string\">\"Could not verify\"</span>, <span class=\"hljs-number\">401</span>, {<span class=\"hljs-string\">\"www-Authenticate\"</span> : <span class=\"hljs-string\">\"Basic realm=Login Required\"</span>})\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">\"__main__\"</span>:\n\tapp.run(debug=<span class=\"hljs-literal\">True</span>)</code></pre>\n"},{"tags":[{"name":"golang","id":"golang-603470"}],"title":"Arrays in Golang","date":null,"description":"","slug":"arrays-in-golang","id":"arrays-in-golang-33038","content":"<p><strong>Defining and Using Arrays</strong></p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> names [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">string</span>\nnames[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">\"akshay\"</span>\nnames[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\"anubhav\"</span>\nnames[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">\"shubham\"</span></code></pre>\n<p><strong>Using the Array Literal Syntax</strong></p>\n<pre><code class=\"hljs language-go\">names := [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">string</span>{<span class=\"hljs-string\">\"akshay\"</span>, <span class=\"hljs-string\">\"anubhav\"</span>, <span class=\"hljs-string\">\"shubham\"</span>}</code></pre>\n<p><strong>Creating Multidimensional Arrays</strong></p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> coords [<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">int</span>\n<span class=\"hljs-comment\">// This statement creates an array whose capacity is 3 and whose underlying type is an int array also with a capacity of 3, producing a 3x3 array of int values.</span>\ncoords[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">10</span></code></pre>\n<p><strong>Assigning an Array to a New Variable</strong></p>\n<pre><code class=\"hljs language-go\">names := [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">string</span>{<span class=\"hljs-string\">\"akshay\"</span>, <span class=\"hljs-string\">\"anubhav\"</span>, <span class=\"hljs-string\">\"shubham\"</span>}\notherArray := names\nnames[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">\"Rahul\"</span>\nfmt.Println(names, otherArray)\n<span class=\"hljs-comment\">// Go works with values, rather than references, by default.</span>\n<span class=\"hljs-comment\">// This behavior extends to arrays, which means that assigning an array to a new variable copies the array and copies the values it contains.</span></code></pre>\n<p><strong>Using a Pointer to an Array</strong></p>\n<pre><code class=\"hljs language-go\">names := [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">string</span>{<span class=\"hljs-string\">\"akshay\"</span>, <span class=\"hljs-string\">\"anubhav\"</span>, <span class=\"hljs-string\">\"shubham\"</span>}\notherArray := &#x26;names\nnames[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">\"Rahul\"</span>\nfmt.Println(names, *otherArray)</code></pre>\n<p><strong>Comparing Arrays</strong></p>\n<pre><code class=\"hljs language-go\">names := [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">string</span>{<span class=\"hljs-string\">\"akshay\"</span>, <span class=\"hljs-string\">\"anubhav\"</span>, <span class=\"hljs-string\">\"shubham\"</span>}\notherNames := [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">string</span>{<span class=\"hljs-string\">\"akshay\"</span>, <span class=\"hljs-string\">\"anubhav\"</span>, <span class=\"hljs-string\">\"shubham\"</span>}\nsame := names == otherNames\n<span class=\"hljs-comment\">// Arrays are equal if they are of the same type and contain equal elements in the same order.</span></code></pre>\n<p><strong>Enumerating an Array</strong></p>\n<pre><code class=\"hljs language-go\">names := [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">string</span>{<span class=\"hljs-string\">\"akshay\"</span>, <span class=\"hljs-string\">\"anubhav\"</span>, <span class=\"hljs-string\">\"shubham\"</span>}\n<span class=\"hljs-keyword\">for</span> index, value := <span class=\"hljs-keyword\">range</span> names {\n\tfmt.Println(<span class=\"hljs-string\">\"Index:\"</span>, index, <span class=\"hljs-string\">\"Value:\"</span>, value)\n}</code></pre>\n<p><strong>Discarding the Current Index</strong></p>\n<pre><code class=\"hljs language-go\">names := [<span class=\"hljs-number\">3</span>]<span class=\"hljs-type\">string</span>{<span class=\"hljs-string\">\"akshay\"</span>, <span class=\"hljs-string\">\"anubhav\"</span>, <span class=\"hljs-string\">\"shubham\"</span>}\n<span class=\"hljs-keyword\">for</span> _, value := <span class=\"hljs-keyword\">range</span> names {\n\tfmt.Println(<span class=\"hljs-string\">\"Value:\"</span>, value)\n}\n<span class=\"hljs-comment\">// The underscore is known as the blank identifier and is used when a feature returns values that are not subsequently used and for which a name should not be assigned</span></code></pre>\n"},{"tags":[{"name":"golang","id":"golang-484356"},{"name":"golang-web","id":"golang-web-239392"}],"title":"Caching Templates in Golang","date":null,"description":"","slug":"caching-templates-in-golang","id":"caching-templates-in-golang-572264","content":"<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> render\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"html/template\"</span>\n    <span class=\"hljs-string\">\"log\"</span>\n    <span class=\"hljs-string\">\"net/http\"</span>\n)\n\n  \n\n<span class=\"hljs-keyword\">var</span> tc = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">string</span>]*template.Template)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">RenderTemplate</span><span class=\"hljs-params\">(w http.ResponseWriter, t <span class=\"hljs-type\">string</span>)</span></span> {\n    <span class=\"hljs-keyword\">var</span> templ *template.Template\n    <span class=\"hljs-keyword\">var</span> err <span class=\"hljs-type\">error</span>\n    <span class=\"hljs-comment\">// Check to see if we already have the template in our cache</span>\n    _, inMap := tc[t]\n    <span class=\"hljs-keyword\">if</span> !inMap {\n        <span class=\"hljs-comment\">// need to create the template</span>\n        log.Println(<span class=\"hljs-string\">\"creating template and adding to cache\"</span>)\n        err = createTemplateCache(t)\n        <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n            log.Println(err)\n        }\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// We have the template in the cache</span>\n        log.Println(<span class=\"hljs-string\">\"using cached template\"</span>)\n    }\n\n    templ = tc[t]\n    err = templ.Execute(w, <span class=\"hljs-literal\">nil</span>)\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n        log.Println(err)\n    }\n}\n\n  \n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">createTemplateCache</span><span class=\"hljs-params\">(t <span class=\"hljs-type\">string</span>)</span></span> <span class=\"hljs-type\">error</span> {\n    templates := []<span class=\"hljs-type\">string</span>{\n        <span class=\"hljs-string\">\"./templates/\"</span> + t,\n        <span class=\"hljs-string\">\"./templates/base.html\"</span>,\n    }\n    <span class=\"hljs-comment\">// parse the template</span>\n    templ, err := template.ParseFiles(templates...)\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-keyword\">return</span> err\n    }\n    <span class=\"hljs-comment\">// add template to cache</span>\n    tc[t] = templ\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}</code></pre>\n"},{"tags":[{"name":"golang","id":"golang-387000"}],"title":"Channels in Golang","date":null,"description":"","slug":"channels-in-golang","id":"channels-in-golang-299636","content":"<p>In Go programming language, a channel is a communication mechanism that allows goroutines (lightweight threads of execution) to communicate with each other and synchronize their actions.</p>\n<p>A channel is a typed conduit through which values can be sent and received. It is similar to a queue or a message broker, where messages are exchanged between different entities in a distributed system.</p>\n<p>Channels can be created using the built-in <code>make</code> function, and are typed by the values they convey. For example, a channel of type <code>int</code> can only send and receive integers.</p>\n<p>Here's an example of creating a channel of type <code>int</code>:</p>\n<pre><code class=\"hljs language-go\">ch := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-type\">int</span>)</code></pre>\n<p>Once a channel is created, values can be sent to the channel using the <code>&#x3C;-</code> operator, and received from the channel using the same operator in the opposite direction. Here's an example of sending and receiving values from a channel:</p>\n<pre><code class=\"hljs language-go\">ch &#x3C;- <span class=\"hljs-number\">42</span> <span class=\"hljs-comment\">// send a value to the channel</span>\nx := &#x3C;-ch <span class=\"hljs-comment\">// receive a value from the channel</span></code></pre>\n<p>Channels can also be used to synchronize the execution of multiple goroutines. For example, a goroutine can wait for a value to be sent to a channel before continuing its execution. This can be done using the <code>select</code> statement, which allows a goroutine to wait on multiple channels simultaneously.</p>\n"},{"tags":[{"name":"golang","id":"golang-882995"}],"title":"Handling JSON in Golang","date":null,"description":"","slug":"handling-json-in-golang","id":"handling-json-in-golang-374438","content":"<h2>Reading JSON</h2>\n<p>In Go, reading JSON data involves decoding a JSON string or stream into a Go data structure using the <code>encoding/json</code> package.</p>\n<p>Here's an example of how to read a JSON string into a Go data structure:</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"encoding/json\"</span>\n\t<span class=\"hljs-string\">\"fmt\"</span>\n)\n\n<span class=\"hljs-keyword\">type</span> Person <span class=\"hljs-keyword\">struct</span> {\n\tName <span class=\"hljs-type\">string</span> <span class=\"hljs-string\">`json:\"name\"`</span>\n\tAge  <span class=\"hljs-type\">int</span>    <span class=\"hljs-string\">`json:\"age\"`</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tjsonStr := <span class=\"hljs-string\">`{\"name\":\"Alice\",\"age\":30}`</span>\n\n\t<span class=\"hljs-keyword\">var</span> person Person\n\terr := json.Unmarshal([]<span class=\"hljs-type\">byte</span>(jsonStr), &#x26;person)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tfmt.Println(<span class=\"hljs-string\">\"error:\"</span>, err)\n\t}\n\n\tfmt.Println(person.Name)\n\tfmt.Println(person.Age)\n}\n</code></pre>\n<p>In the example above, we first define a Go struct <code>Person</code> that matches the JSON data format. The struct has two fields: <code>Name</code> and <code>Age</code>.</p>\n<p>Then, we use the <code>json.Unmarshal</code> function to decode the JSON string <code>jsonStr</code> into a <code>Person</code> struct instance. The <code>&#x26;person</code> argument passed to <code>json.Unmarshal</code> specifies that the decoded data should be stored in the <code>person</code> variable, which is a pointer to a <code>Person</code> struct.</p>\n<p>If the JSON string is valid and can be decoded into a <code>Person</code> struct, the decoded values will be stored in the <code>person</code> variable. We can then access the <code>Name</code> and <code>Age</code> fields of the <code>person</code> variable to print their values.</p>\n<p>Note that if the JSON string does not match the <code>Person</code> struct format or contains invalid data, the <code>json.Unmarshal</code> function will return an error. It is important to handle these errors properly in your code.</p>\n<h2>Writing JSON</h2>\n<p>In Go, writing JSON data involves encoding a Go data structure into a JSON string or stream using the <code>encoding/json</code> package.</p>\n<p>Here's an example of how to write a Go data structure as a JSON string:</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"encoding/json\"</span>\n\t<span class=\"hljs-string\">\"fmt\"</span>\n\t<span class=\"hljs-string\">\"os\"</span>\n)\n\n<span class=\"hljs-keyword\">type</span> Person <span class=\"hljs-keyword\">struct</span> {\n\tName <span class=\"hljs-type\">string</span> <span class=\"hljs-string\">`json:\"name\"`</span>\n\tAge  <span class=\"hljs-type\">int</span>    <span class=\"hljs-string\">`json:\"age\"`</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tperson := Person{Name: <span class=\"hljs-string\">\"Alice\"</span>, Age: <span class=\"hljs-number\">30</span>}\n\n\tjsonData, err := json.Marshal(person)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tfmt.Println(<span class=\"hljs-string\">\"error:\"</span>, err)\n\t\tos.Exit(<span class=\"hljs-number\">1</span>)\n\t}\n\n\tfmt.Println(<span class=\"hljs-type\">string</span>(jsonData))\n}\n</code></pre>\n<p>In the example above, we first define a Go struct <code>Person</code> that matches the JSON data format. The struct has two fields: <code>Name</code> and <code>Age</code>.</p>\n<p>Then, we create an instance of the <code>Person</code> struct and populate it with data. In this example, we set the <code>Name</code> field to \"Alice\" and the <code>Age</code> field to 30.</p>\n<p>Next, we use the <code>json.Marshal</code> function to encode the <code>Person</code> struct instance into a JSON string. The resulting <code>jsonData</code> variable will contain a byte slice representing the JSON data.</p>\n<p>Finally, we convert the byte slice to a string using <code>string(jsonData)</code> and print it to the console.</p>\n<p>Note that if the <code>Person</code> struct contains fields that are not compatible with JSON (e.g. a private field), you can use struct tags to customize the JSON encoding behavior. In this example, we use the <code>json</code> struct tag to map the struct field names to the corresponding JSON field names.</p>\n"},{"tags":[{"name":"golang","id":"golang-33329"}],"title":"Reading User Input in Golang","date":null,"description":"","slug":"reading-user-input-in-golang","id":"reading-user-input-in-golang-234469","content":"<p>In Golang, there are multiple ways to take user input. The most common methods are using the <code>fmt</code> package functions like <code>fmt.Scan()</code>, <code>fmt.Scanln()</code>, and <code>fmt.Scanf()</code>, or using the <code>bufio</code> package with <code>bufio.NewReader()</code> or <code>bufio.NewScanner()</code>.</p>\n<p>Here are some examples and trade-offs for each approach:</p>\n<ol>\n<li><code>fmt.Scan()</code>, <code>fmt.Scanln()</code>, and <code>fmt.Scanf()</code>:</li>\n</ol>\n<p><strong>Example:</strong></p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"fmt\"</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">var</span> name <span class=\"hljs-type\">string</span>\n    fmt.Print(<span class=\"hljs-string\">\"Enter your name: \"</span>)\n    fmt.Scan(&#x26;name)\n    fmt.Printf(<span class=\"hljs-string\">\"Name: %s\"</span>, name)\n}</code></pre>\n<p>Pros:\n- Simple and easy to use for basic input requirements.\n- No need to import additional packages other than <code>fmt</code>.</p>\n<p>Cons:\n- Limited flexibility when handling more complex input situations.</p>\n<p>Note: <code>fmt.Scanln()</code> is used to take input in the next line, while <code>fmt.Scan()</code> is used to take input in the same line <a href=\"https://www.geeksforgeeks.org/how-to-take-input-from-the-user-in-golang/\">Source 1</a>.</p>\n<ol start=\"2\">\n<li><code>bufio.NewReader()</code>:</li>\n</ol>\n<p><strong>Example:</strong></p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"bufio\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"os\"</span>\n    <span class=\"hljs-string\">\"strings\"</span>\n)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    fmt.Print(<span class=\"hljs-string\">\"Enter text: \"</span>)\n    reader := bufio.NewReader(os.Stdin)\n    input, err := reader.ReadString(<span class=\"hljs-string\">'\\n'</span>)\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n        fmt.Println(<span class=\"hljs-string\">\"An error occurred while reading input. Please try again\"</span>, err)\n        <span class=\"hljs-keyword\">return</span>\n    }\n    input = strings.TrimSuffix(input, <span class=\"hljs-string\">\"\\n\"</span>)\n    fmt.Println(input)\n}</code></pre>\n<p>Pros:\n- Good for reading a single line of text.\n- Can handle more complex input scenarios compared to <code>fmt.Scan()</code> functions.</p>\n<p>Cons:\n- Requires importing the <code>bufio</code> package <a href=\"https://freshman.tech/snippets/go/read-console-input/\">Source 4</a>.</p>\n<ol start=\"3\">\n<li><code>bufio.NewScanner()</code>:</li>\n</ol>\n<p><strong>Example:</strong></p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">\"bufio\"</span>\n    <span class=\"hljs-string\">\"fmt\"</span>\n    <span class=\"hljs-string\">\"os\"</span>\n)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    scanner := bufio.NewScanner(os.Stdin)\n    <span class=\"hljs-keyword\">for</span> {\n        fmt.Print(<span class=\"hljs-string\">\"Enter Text: \"</span>)\n        scanner.Scan()\n        text := scanner.Text()\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(text) != <span class=\"hljs-number\">0</span> {\n            fmt.Println(text)\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">break</span>\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> scanner.Err() != <span class=\"hljs-literal\">nil</span> {\n        fmt.Println(<span class=\"hljs-string\">\"Error: \"</span>, scanner.Err())\n    }\n}</code></pre>\n<p>Pros:\n- Suitable for reading multiple lines of text.\n- More flexible than <code>fmt.Scan()</code> functions.</p>\n<p>Cons:\n- Requires importing the <code>bufio</code> package <a href=\"https://freshman.tech/snippets/go/read-console-input/\">Source 4</a>.</p>\n<p>In summary, if you need simple input handling, go with <code>fmt.Scan()</code> functions. For more complex input scenarios, use <code>bufio.NewReader()</code> or <code>bufio.NewScanner()</code> depending on whether you need to read a single line or multiple lines of text.</p>\n"},{"tags":[{"name":"golang","id":"golang-744338"}],"title":"ResponseWriter in Golang","date":null,"description":"","slug":"responsewriter-in-golang","id":"responsewriter-in-golang-189874","content":"<p>In Go, the <code>ResponseWriter</code> interface is provided by the <code>net/http</code> package and is used to write the HTTP response back to the client. When a client sends an HTTP request to a server, the server processes the request and generates an HTTP response. The <code>ResponseWriter</code> interface allows the server to write the response back to the client.</p>\n<p>The <code>ResponseWriter</code> interface has a few methods that are used to write the response:</p>\n<ul>\n<li>\n<p><code>Header()</code> - This method returns a <code>Header</code> object that represents the headers of the HTTP response. You can use this method to set response headers such as the content type, cache-control, etc.</p>\n</li>\n<li>\n<p><code>Write([]byte)</code> - This method is used to write the response body. The body is typically a byte slice that represents the content of the response.</p>\n</li>\n<li>\n<p><code>WriteHeader(int)</code> - This method is used to set the HTTP status code of the response. For example, if the server wants to send a response with a 404 status code (page not found), it can call this method with the argument 404.</p>\n</li>\n</ul>\n<p>Here's an example of how to use the <code>ResponseWriter</code> interface in Go:</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">handler</span><span class=\"hljs-params\">(w http.ResponseWriter, r *http.Request)</span></span> {\n    w.Header().Set(<span class=\"hljs-string\">\"Content-Type\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>)\n    w.WriteHeader(http.StatusOK)\n    w.Write([]<span class=\"hljs-type\">byte</span>(<span class=\"hljs-string\">\"Hello, World!\"</span>))\n}\n</code></pre>\n<p>In this example, the <code>handler</code> function takes a <code>ResponseWriter</code> and an <code>http.Request</code> object as arguments. It first sets the content type header to <code>text/plain</code>, then sets the HTTP status code to <code>200 OK</code> using <code>WriteHeader</code>, and finally writes the response body <code>Hello, World!</code> using the <code>Write</code> method.</p>\n"},{"tags":[{"name":"golang","id":"golang-909132"}],"title":"Slices in Golang","date":null,"description":"","slug":"slices-in-golang","id":"slices-in-golang-139772","content":"<p>Slices are a variable-length array. They are useful when you do not know how many values you need to store or when the number changes over time.</p>\n<h3>Defining a Slice</h3>\n<pre><code class=\"hljs language-go\">names := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">string</span>, <span class=\"hljs-number\">3</span>)</code></pre>\n<p>The <code>make</code> function accepts arguments that specify the type and length of the slice.</p>\n<h3>Using the Literal Syntax</h3>\n<pre><code class=\"hljs language-go\">names := []<span class=\"hljs-type\">string</span>{<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"c\"</span>}</code></pre>\n<p>The slice is a data structure that contains three values: a pointer to the array, the length of the slice, and the capacity of the slice.</p>\n<h3>Appending elements to a Slice</h3>\n<pre><code class=\"hljs language-go\">names := []<span class=\"hljs-type\">string</span>{<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"c\"</span>}\nnames := <span class=\"hljs-built_in\">append</span>(names, <span class=\"hljs-string\">\"d\"</span>)</code></pre>\n<p>The built-in <code>append</code> function accepts a slice and one or more elements to add to the slice, separated by commas and returns a new slice.</p>\n<h3>Allocating Additional Slice Capacity</h3>\n<p>Creating and copying arrays can be inefficient. If you expect that you will need to append items to a slice, you can specify additional capacity when using the <code>make</code> function.</p>\n<pre><code class=\"hljs language-go\">names := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">string</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>)</code></pre>\n<p>Slices have a <em>length</em> and a <em>capacity</em>. The length of a slice is how many values it can currently contain, while the number of elements that can be stored in the underlying array before the slice must be resized and a new created.</p>\n<pre><code class=\"hljs language-go\">names := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">string</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>)\nnames[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">\"a\"</span>\nnewNames := <span class=\"hljs-built_in\">append</span>(names, <span class=\"hljs-string\">\"b\"</span>)\nnewNames[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">\"A\"</span>\nfmt.Println(names, newNames) <span class=\"hljs-comment\">// => [A  ] [A   b]</span>\n</code></pre>\n<p>The underlying array is not replaced when the <code>append</code> function is called on a slice with enough capacity to accommodate the new elements.</p>\n<p>The built-in <code>len</code> and <code>cap</code> functions returns the length and capacity of a slice.</p>\n<p>If you define a Slice but do not initialize it, then the result is a slice that has a length of zero and a capacity of zero, and this will cause an error when an element is appended to it.</p>\n<h3>Appending One Slice to Another</h3>\n<p>The <code>append</code> function can be used to append one slice to another.</p>\n<pre><code class=\"hljs language-go\">names := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">string</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>)\nnames[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">\"Kayak\"</span>\nnames[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\"Lifejacket\"</span>\nnames[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">\"Paddle\"</span>\nmoreNames := []<span class=\"hljs-type\">string</span> { <span class=\"hljs-string\">\"Hat Gloves\"</span>}\nappendedNames := <span class=\"hljs-built_in\">append</span>(names, moreNames...)</code></pre>\n<h3>Creatting Slices from Existing Arrays</h3>\n<pre><code class=\"hljs language-go\">products := [<span class=\"hljs-number\">4</span>]<span class=\"hljs-type\">string</span> { <span class=\"hljs-string\">\"Kayak\"</span>, <span class=\"hljs-string\">\"Lifejacket\"</span>, <span class=\"hljs-string\">\"Paddle\"</span>, <span class=\"hljs-string\">\"Hat\"</span>}\nfewNames := products[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">3</span>]\nallNames := products[:]</code></pre>\n<p>The <code>products</code> variable is assigned a standard, fixed-length array containing <code>string</code> values. The array is used to create slices using a range.</p>\n<p>The two slices are backed by the same array. The <code>fewNames</code>  has a partial view of the array, while the <code>allNames</code> slice is a view of the entire array.</p>\n<h3>Appending Elements When using Arrays for Slices</h3>\n<p>The relationship between the slice and the existing array can create different results when appending elements.</p>\n<p><strong>Displaying Slice Length and Capacity</strong></p>\n<pre><code class=\"hljs language-go\">products := [<span class=\"hljs-number\">4</span>]<span class=\"hljs-type\">string</span> { <span class=\"hljs-string\">\"Kayak\"</span>, <span class=\"hljs-string\">\"Lifejacket\"</span>, <span class=\"hljs-string\">\"Paddle\"</span>, <span class=\"hljs-string\">\"Hat\"</span>}\nsomeNames := products[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">3</span>]\nallNames := products[:]\n\nfmt.Println(<span class=\"hljs-built_in\">len</span>(someNames), <span class=\"hljs-built_in\">cap</span>(someNames)) <span class=\"hljs-comment\">// => 2 , 3</span>\nfmt.Println(<span class=\"hljs-built_in\">len</span>(allNames), <span class=\"hljs-built_in\">cap</span>(allNames)) <span class=\"hljs-comment\">// => 4, 4</span></code></pre>\n<p><strong>Appending an Element to a Slice</strong></p>\n<pre><code class=\"hljs language-go\">products := [<span class=\"hljs-number\">4</span>]<span class=\"hljs-type\">string</span>{<span class=\"hljs-string\">\"Kayak\"</span>, <span class=\"hljs-string\">\"Lifejacket\"</span>, <span class=\"hljs-string\">\"Paddle\"</span>, <span class=\"hljs-string\">\"Hat\"</span>}\nsomeNames := products[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">3</span>]\nallNames := products[:]\nsomeNames = <span class=\"hljs-built_in\">append</span>(someNames, <span class=\"hljs-string\">\"New\"</span>)\nfmt.Println(someNames, allNames) <span class=\"hljs-comment\">// => [Lifejacket Paddle New] [Kayak Lifejacket Paddle New]</span></code></pre>\n<p>The slice <code>someNames</code> had the capacity to accommodate the new element without resizing, but the array location that will be used to store the element is already included in the <code>allNames</code> slice, which means that the <code>append</code> operation expands the <code>someNames</code> slice and changes one of the values that can be accessed through the <code>allNames</code> slice.</p>\n<h3>Making Slices Predicable</h3>\n<p>The way that slices can share an array causes confusion. Some developers expect slices to be independent and get unexpected results when a value is stored in an array used by multiple slices. Other developers write code that expects shared arrays and get unexpected results when a resize separates slices.</p>\n<p>Slices can appear unpredictable but only if you treat them inconsistently. My advice is to divide slices into two categories, decide which of them a slice belongs to when it is created, and not change that category.</p>\n<p>The first category is as a fixed-length view into a fixed-length array. This is more useful than it sounds because slices can be mapped onto a specific region of an array, which can be selected programmatically. In this category, you can change the elements in the slice but not append new elements, meaning that all slices mapped into that array will use the modified elements.</p>\n<p>The second category is as a variable-length data collection. I make sure each slice in this category has its own backing array, which is not shared by any other slice. This approach allows me to freely add new elements to the slice without having to worry about the impact on other slices.</p>\n<p>If you get bogged down with slices and don’t get the results you expect, then ask yourself which category each of your slices falls into and whether you are treating a slice inconsistently or creating slices from different categories from the same source array</p>\n<p>If you use a slice as a fixed view onto an array, then you can expect multiple slices to give you a consistent view of that array, and any new values you assign will be reflected by all of the slices that map into the modified element.</p>\n<h3>Specifying Capacity When Creating a Slice from an Array</h3>\n<p>Ranges can include a maximum capacity, which provides some degree of control over when arrays will be duplicated.</p>\n<pre><code class=\"hljs language-go\">products := [<span class=\"hljs-number\">4</span>]<span class=\"hljs-type\">string</span> { <span class=\"hljs-string\">\"Kayak\"</span>, <span class=\"hljs-string\">\"Lifejacket\"</span>, <span class=\"hljs-string\">\"Paddle\"</span>, <span class=\"hljs-string\">\"Hat\"</span>}\nsomeNames := products[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">3</span>:<span class=\"hljs-number\">3</span>]</code></pre>\n<p>The additional value, known as the max value, is specified after the high value, and must be within the bounds of the array that is being sliced.</p>\n<p>The max value doesn’t specify the maximum capacity directly. Instead, the maximum capacity is determined by subtracting the low value from the max value. In the case of the example, the max value is 3, and the low value is 1, which means that the capacity will be limited to 2. The result is that the append operation causes the slice to be resized and allocated its own array, rather than expanding in the existing array.</p>\n<h3>Creating Slices from Other Slices</h3>\n<p>Slices can also be created from other slices, although the relationship between slices isn’t preserved if they are resized.</p>\n<pre><code class=\"hljs language-go\">products := [<span class=\"hljs-number\">4</span>]<span class=\"hljs-type\">string</span> { <span class=\"hljs-string\">\"Kayak\"</span>, <span class=\"hljs-string\">\"Lifejacket\"</span>, <span class=\"hljs-string\">\"Paddle\"</span>, <span class=\"hljs-string\">\"Hat\"</span>}\nallNames := products[<span class=\"hljs-number\">1</span>:]\n<span class=\"hljs-comment\">// The range creates a slice that is mapped onto all but the first element of the source array.</span>\nsomeNames := allNames[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">3</span>]\n<span class=\"hljs-comment\">// This range creates a slice that maps onto the second and third elements in the allNames slice.</span>\n\nallNames = <span class=\"hljs-built_in\">append</span>(allNames, <span class=\"hljs-string\">\"Gloves\"</span>)\nallNames[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">\"Canoe</span></code></pre>\n<p>Using one slice to create another is an effective way of carrying over offset start locations. But remember that slices are essentially pointers to sections of arrays, which means they can’t point at another slice. In reality, the ranges are used to determine the mappings for slices that are backed by the same array.</p>\n<p><img src=\"https://i.imgur.com/8UUxZmN.png\" alt=\"\"></p>\n<p><img src=\"https://i.imgur.com/F4ILGi1.png\" alt=\"\"></p>\n<p>The slices behave consistently and will be resized if elements are appended when there is no available capacity, at which point they will no longer share a common array.</p>\n<h3>Using the copy Function</h3>\n<p>The copy function is used to copy elements between slices. This function can be used to ensure that slices have separate arrays and to create slices that combine elements from different sources.</p>\n<p>The copy function accepts two arguments, which are the destination slice and the source slice.</p>\n<p><img src=\"https://i.imgur.com/4hNn3Kb.png\" alt=\"\"></p>\n<p>The function copies elements to the target slice. The slices don’t need to have the same length because the copy function will copy elements only until the end of the destination or source slice is reached. The destination slice is not resized, even when there is capacity available in the existing backing array, which means that you must ensure there is sufficient length to accommodate the number of elements you want to copy.</p>\n"},{"tags":[{"name":"golang","id":"golang-853761"},{"name":"golang-web","id":"golang-web-262158"}],"title":"Serving HTML Templates in Golang","date":null,"description":"","slug":"serving-html-templates-in-golang","id":"serving-html-templates-in-golang-664209","content":"<p>In Go, serving HTML templates involves using the <code>html/template</code> package to parse and execute template files, and the <code>net/http</code> package to serve the generated HTML to clients.</p>\n<p>Here's an example of how to serve an HTML template in Go:</p>\n<ol>\n<li>Create an HTML template file (e.g. <code>template.html</code>) with placeholders for dynamic data. For example:</li>\n</ol>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&#x3C;!DOCTYPE <span class=\"hljs-keyword\">html</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">html</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">head</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">title</span>></span>{{.Title}}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">title</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">head</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">body</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>{{.Heading}}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{{.Message}}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">body</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">html</span>></span></code></pre>\n<ol start=\"2\">\n<li>Define a Go struct that holds the data to be displayed in the template. For example:</li>\n</ol>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> TemplateData <span class=\"hljs-keyword\">struct</span> {\n    Title   <span class=\"hljs-type\">string</span>\n    Heading <span class=\"hljs-type\">string</span>\n    Message <span class=\"hljs-type\">string</span>\n}</code></pre>\n<ol start=\"3\">\n<li>Parse the template file using the <code>template.ParseFiles</code> function. For example:</li>\n</ol>\n<pre><code class=\"hljs language-go\">tmpl, err := template.ParseFiles(<span class=\"hljs-string\">\"template.html\"</span>)\n<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n    <span class=\"hljs-built_in\">panic</span>(err)\n}\n</code></pre>\n<ol start=\"4\">\n<li>Define a handler function that executes the template and writes the generated HTML to the HTTP response. For example:</li>\n</ol>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">handleTemplate</span><span class=\"hljs-params\">(w http.ResponseWriter, r *http.Request)</span></span> {\n    data := TemplateData{\n        Title:   <span class=\"hljs-string\">\"My Page\"</span>,\n        Heading: <span class=\"hljs-string\">\"Welcome to my page\"</span>,\n        Message: <span class=\"hljs-string\">\"This is a test message\"</span>,\n    }\n    err := tmpl.Execute(w, data)\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-built_in\">panic</span>(err)\n    }\n}\n</code></pre>\n<ol start=\"5\">\n<li>Register the handler function with the HTTP server using the <code>http.HandleFunc</code> function. For example:</li>\n</ol>\n<pre><code class=\"hljs language-go\">http.HandleFunc(<span class=\"hljs-string\">\"/\"</span>, handleTemplate)</code></pre>\n<ol start=\"6\">\n<li>Start the HTTP server using the <code>http.ListenAndServe</code> function. For example:</li>\n</ol>\n<pre><code class=\"hljs language-go\">err := http.ListenAndServe(<span class=\"hljs-string\">\":8080\"</span>, <span class=\"hljs-literal\">nil</span>)\n<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n    <span class=\"hljs-built_in\">panic</span>(err)\n}</code></pre>\n<p>When a client makes a request to the root URL (\"/\"), the <code>handleTemplate</code> function will be called. This function creates a <code>TemplateData</code> struct with some example data, executes the <code>tmpl</code> template with this data using the <code>tmpl.Execute</code> function, and writes the generated HTML to the HTTP response using the <code>http.ResponseWriter</code> interface.</p>\n<p>To run the web application, save the code to a file (e.g. <code>main.go</code>) and run the following command in a terminal:</p>\n<p><code>$ go run main.go</code></p>\n<p>This will start the web server and output a message indicating that it's listening on port 8080. You can then open a web browser and navigate to <code>http://localhost:8080</code> to see the rendered HTML template.</p>\n"},{"tags":[{"name":"golang","id":"golang-40758"},{"name":"golang-web","id":"golang-web-859482"}],"title":"Serving Stylesheets in Golang","date":null,"description":"","slug":"serving-stylesheets-in-golang","id":"serving-stylesheets-in-golang-384929","content":"<p>In Go, you can serve static files such as CSS stylesheets using the <code>http.FileServer</code> and <code>http.Handle</code> functions provided by the <code>net/http</code> package.</p>\n<p>Here's an example of how to serve a CSS stylesheet in Go:</p>\n<ol>\n<li>Create a directory to store your static files (e.g. <code>static/</code>).</li>\n<li>Move the CSS stylesheet file to the static directory.</li>\n<li>Use the <code>http.FileServer</code> function to create a file server that serves files from the static directory. For example:</li>\n</ol>\n<pre><code class=\"hljs language-go\">fs := http.FileServer(http.Dir(<span class=\"hljs-string\">\"static\"</span>))</code></pre>\n<ol start=\"4\">\n<li>Use the <code>http.Handle</code> function to register the file server with a URL prefix. For example:</li>\n</ol>\n<pre><code class=\"hljs language-go\">http.Handle(<span class=\"hljs-string\">\"/static/\"</span>, http.StripPrefix(<span class=\"hljs-string\">\"/static/\"</span>, fs))\n</code></pre>\n<p>This code maps requests to URLs that start with \"/static/\" to the file server, and strips the \"/static/\" prefix from the URLs before looking for files on the file system. This allows you to use relative URLs in your HTML files, such as <code>&#x3C;link rel=\"stylesheet\" href=\"/static/style.css\"></code>.</p>\n<p>When a client requests a file from the \"/static/\" URL prefix (e.g. <code>/static/style.css</code>), the <code>http.FileServer</code> function will look for the file in the <code>static/</code> directory and serve it to the client with the appropriate content type.</p>\n"},{"tags":[{"name":"golang","id":"golang-380396"},{"name":"golang-web","id":"golang-web-839569"}],"title":"Simple Web Server in Golang","date":null,"description":"","slug":"simple-web-server-in-golang","id":"simple-web-server-in-golang-793368","content":"<p>Here is an example of a simple \"Hello World\" web application in Go using the <code>net/http</code> package.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"fmt\"</span>\n\t<span class=\"hljs-string\">\"net/http\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>{\n\thttp.HandleFunc(<span class=\"hljs-string\">\"/\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(w http.ResponseWriter, r *http.Request )</span></span> {\n\t\tn, err := fmt.Fprintf(w, <span class=\"hljs-string\">\"Hello World!\"</span>)\n\t\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t\t<span class=\"hljs-built_in\">panic</span>(err)\n\t\t}\n\t\tfmt.Println(<span class=\"hljs-string\">\"Bytes written:\"</span>, n)\n\t\t\n\t})\n\tfmt.Println(<span class=\"hljs-string\">\"Starting server on the port 8000...\"</span>)\n\terr := http.ListenAndServe(<span class=\"hljs-string\">\":8000\"</span>, <span class=\"hljs-literal\">nil</span>)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-built_in\">panic</span>(err)\n\t}\n}</code></pre>\n<p>The <code>http.HandleFunc</code> function is used to map incoming requests to the root <code>(\"/\")</code> to a function that writes the \"Hello, World!\" response to the client using the <code>fmt.Fprintf</code> function.</p>\n"},{"title":"How to upload a image in Django","date":null,"description":"","slug":"how-to-upload-a-image-in-django","id":"how-to-upload-a-image-in-django-465429","tags":[],"content":"<ol>\n<li>First, you need to create a model for your image. This model should include fields for the image file, as well as any additional information you wish to store about the image, such as a caption or title.</li>\n</ol>\n<pre><code class=\"hljs language-py\"><span class=\"hljs-keyword\">from</span> django.db <span class=\"hljs-keyword\">import</span> models\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Image</span>(models.Model):\n\ttitle = models.Charfield(max_length = <span class=\"hljs-number\">255</span>)\n\timage = models.ImageField(upload_to=<span class=\"hljs-string\">'images/'</span>)\n\tuploaded_at = models.DateTimeField(auto_now_add=<span class=\"hljs-literal\">True</span>)</code></pre>\n<ol start=\"2\">\n<li>Next, you will need to create a form that will handle the image upload. This form should include a file field for the image, as well as any additional fields that you have included in your model.</li>\n</ol>\n<pre><code class=\"hljs language-py\"><span class=\"hljs-keyword\">from</span> django <span class=\"hljs-keyword\">import</span> forms\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ImageForm</span>(forms.ModelForm):\n\t<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Meta</span>:\n\t\tmodel = Image\n\t\tfields = (<span class=\"hljs-string\">'title'</span>, <span class=\"hljs-string\">'image'</span>)</code></pre>\n<ol start=\"3\">\n<li>In your <code>views.py</code>  you will need to create a view that will handle the image upload. This view should handle the form submission, the save the image to the database.</li>\n</ol>\n<pre><code class=\"hljs language-py\"><span class=\"hljs-keyword\">from</span> django.shortcuts <span class=\"hljs-keyword\">import</span> render\n<span class=\"hljs-keyword\">from</span> .forms <span class=\"hljs-keyword\">import</span> ImageForm\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_image</span>(<span class=\"hljs-params\">request</span>):\n\t<span class=\"hljs-keyword\">if</span> request.method == <span class=\"hljs-string\">'POST'</span>:\n\t\tform = ImageForm(request.POST, request.FILES)\n\t\t<span class=\"hljs-keyword\">if</span> form.is_valid():\n\t\t\tform.save()\n\t\t\t<span class=\"hljs-keyword\">return</span> redirect(<span class=\"hljs-string\">'success'</span>)\n\t<span class=\"hljs-keyword\">else</span>:\n\t\tform = ImageForm()\n\t<span class=\"hljs-keyword\">return</span> render(request, <span class=\"hljs-string\">'upload.html'</span>, {<span class=\"hljs-string\">\"form\"</span>, <span class=\"hljs-string\">\"form\"</span>})</code></pre>\n<ol start=\"4\">\n<li>Finally, you will need to create a template that will handle the image upload. This template should include a form that allow users to select and upload an image, as well as any additional fields that you have included in your model.</li>\n</ol>\n<pre><code class=\"hljs language-py\">&#x3C;form method=<span class=\"hljs-string\">\"post\"</span> enctype=<span class=\"hljs-string\">\"multipart/form-data\"</span>>\n\t{% csrf_token %}\n\t{{ form.as_p }}\n&#x3C;<span class=\"hljs-built_in\">input</span> <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"submit\"</span> value=<span class=\"hljs-string\">\"Upload\"</span>></code></pre>\n<p>In this way you can upload image in django easily. You can also add validation, image compression, and other functionality to the image upload process.</p>\n"},{"title":"Introduction to routing in Next.js using App Router","date":"2023-06-01 20:18","tags":[{"name":"nextjs","id":"nextjs-959192"},{"name":"app-router","id":"app-router-441083"}],"description":"","slug":"introduction-to-routing-in-nextjs-using-app-router","id":"introduction-to-routing-in-nextjs-using-app-router-801821","content":"<p>The skeleton of every application is routing. This page will introduce you to the <strong>fundamental concepts</strong> of routing for the web and how to handle routing in Next.js.</p>\n<h2>Terminology</h2>\n<p>First, you will see these terms being used throughout the documentation. Here's a quick reference:</p>\n<p><img src=\"https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fterminology-component-tree.png&#x26;w=1920&#x26;q=75\" alt=\"Terminology Component Tree\"></p>\n<ul>\n<li><strong>Tree:</strong> A convention for visualizing a hierarchical structure. For example, a component tree with parent and children components, a folder structure, etc.</li>\n<li><strong>Subtree:</strong> Part of a tree, starting at a new root (first) and ending at the leaves (last).</li>\n<li><strong>Root</strong>: The first node in a tree or subtree, such as a root layout.</li>\n<li><strong>Leaf:</strong> Nodes in a subtree that have no children, such as the last segment in a URL path.</li>\n</ul>\n<p><img src=\"https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fterminology-url-anatomy.png&#x26;w=1920&#x26;q=75\" alt=\"\"></p>\n<ul>\n<li><strong>URL Segment:</strong> Part of the URL path delimited by slashes.</li>\n<li><strong>URL Path:</strong> Part of the URL that comes after the domain (composed of segments).</li>\n</ul>\n<h2>The app directory</h2>\n<p>In version 13, Next.js introduced a new <strong>App Router</strong> built on <a href=\"https://nextjs.org/docs/getting-started/react-essentials#server-components\">React Server Components</a>, which supports shared layouts, nested routing, loading states, error handling, and more.</p>\n<p>The App Router works in a new directory named <code>app</code>. The <code>app</code> directory works alongside the <code>pages</code> directory to allow for incremental adoption. This allows you to opt some routes of your application into the new behavior while keeping other routes in the <code>pages</code> directory for previous behavior. If your application uses the <code>pages</code> directory, please also see the <a href=\"https://nextjs.org/docs/pages/building-your-application/routing\">Pages Router</a> documentation.</p>\n<p>By default, components inside <code>app</code> are <a href=\"https://nextjs.org/docs/getting-started/react-essentials#server-components\">React Server Components</a>. This is a performance optimization and allows you to easily adopt them, and you can also use <a href=\"https://nextjs.org/docs/getting-started/react-essentials#client-components\">Client Components</a>.</p>\n<blockquote>\n<p><strong>Recommendation:</strong> Check out the <a href=\"https://nextjs.org/docs/getting-started/react-essentials\">Server and Client Components</a> page if you're new to Server Components.</p>\n</blockquote>\n<h2>Roles of Folders and Files</h2>\n<p>Next.js uses a file-system based router where:</p>\n<ul>\n<li><strong>Folders</strong> are used to define routes. A route is a single path of nested folders, following the file-system hierarchy from the <strong>root folder</strong> down to a final <strong>leaf folder</strong> that includes a <code>page.js</code> file. See <a href=\"https://nextjs.org/docs/app/building-your-application/routing/defining-routes\">Defining Routes</a>.</li>\n<li><strong>Files</strong> are used to create UI that is shown for a route segment. See <a href=\"https://nextjs.org/docs/app/building-your-application/routing#file-conventions\">special files</a>.</li>\n</ul>\n<h2>Route Segments</h2>\n<p>Each folder in a route represents a <strong>route segment</strong>. Each route segment is mapped to a corresponding <strong>segment</strong> in a <strong>URL path</strong>.</p>\n<p><img src=\"https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Froute-segments-to-path-segments.png&#x26;w=1920&#x26;q=75\" alt=\"\"></p>\n<h2>Nested Routes</h2>\n<p>To create a nested route, you can nest folders inside each other. For example, you can add a new <code>/dashboard/settings</code> route by nesting two new folders in the <code>app</code> directory.</p>\n<p>The <code>/dashboard/settings</code> route is composed of three segments:</p>\n<ul>\n<li><code>/</code> (Root segment)</li>\n<li><code>dashboard</code> (Segment)</li>\n<li><code>settings</code> (Leaf segment)</li>\n</ul>\n<h2>File Conventions</h2>\n<p>Next.js provides a set of special files to create UI with specific behavior in nested routes:</p>\n<ul>\n<li><strong>layout</strong> : Shared UI for a segment and its children</li>\n<li><strong>page</strong> :  Unique UI of a route and make routes publicly accessible</li>\n<li><strong>loading</strong> : Loading UI for a segment and its children</li>\n<li><strong>not-found</strong> : Not found UI for a segment and its children</li>\n<li><strong>error</strong> : Error UI for a segment and its children</li>\n<li><strong>global-error</strong> : Global error UI</li>\n<li><strong>route</strong> : Server-side API endpoint</li>\n<li><strong>template</strong> : Specialized re-rendered Layout UI</li>\n<li><strong>default</strong> : Fallback UI for <a href=\"https://nextjs.org/docs/app/building-your-application/routing/parallel-routes\">Parallel Routes</a></li>\n</ul>\n<h2>Component Hierarchy</h2>\n<p>The React components defined in special files of a route segment are rendered in a specific hierarchy:</p>\n<ul>\n<li><code>layout.js</code></li>\n<li><code>template.js</code></li>\n<li><code>error.js</code> (React error boundary)</li>\n<li><code>loading.js</code> (React suspense boundary)</li>\n<li><code>not-found.js</code> (React error boundary)</li>\n<li><code>page.js</code> or nested <code>layout.js</code></li>\n</ul>\n<pre><code class=\"hljs language-jsx\">&#x3C;<span class=\"hljs-title class_\">Layout</span>>\n\t<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Template</span>></span>\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ErrorBoundary</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&#x3C;<span class=\"hljs-attr\">Error</span> /></span>}>\n\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&#x3C;<span class=\"hljs-attr\">Loading</span> /></span>}/>\n\t\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ErrorBoundary</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&#x3C;<span class=\"hljs-attr\">NotFound</span> /></span>}>\n\t\t\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Page</span> /></span>\n\t\t\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ErrorBoundary</span>></span>\n\t\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Suspense</span>></span>\n\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ErrorBoundary</span>></span></span>\n\t&#x3C;/<span class=\"hljs-title class_\">Template</span>>\n&#x3C;/<span class=\"hljs-title class_\">Layout</span>></code></pre>\n<p>In a nested route, the components of a segment will be nested <strong>inside</strong> the components of its parent segment.</p>\n<pre><code class=\"hljs language-jsx\">\n&#x3C;<span class=\"hljs-title class_\">Layout</span>>\n\t<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ErrorBoundary</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&#x3C;<span class=\"hljs-attr\">Error</span> /></span>}>\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&#x3C;<span class=\"hljs-attr\">Loading</span> /></span>}/>\n\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Layout</span>></span>\n\t\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ErrorBoundary</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&#x3C;<span class=\"hljs-attr\">Error</span> /></span>}>\n\t\t\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>&#x3C;<span class=\"hljs-attr\">Loading</span> /></span>}>\n\t\t\t\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Page</span> /></span>\n\t\t\t\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Suspense</span>></span>\n\t\t\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ErrorBoundary</span>></span>\n\t\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Layout</span>></span>\n\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Suspense</span>></span></span>\n\t&#x3C;/<span class=\"hljs-title class_\">ErrorBoundary</span>>\n&#x3C;/<span class=\"hljs-title class_\">Layout</span>>\n</code></pre>\n<h2>Colocation</h2>\n<p>In addition to special files, you have the option to colocate your own files (e.g. components, styles, tests, etc.) inside folders in the <code>app</code> directory.</p>\n<p>This is because while folders define routes, only the contents returned by <code>page.js</code> or <code>route.js</code> are publicly addressable.</p>\n<p><img src=\"https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fproject-organization-colocation.png&#x26;w=1920&#x26;q=75\" alt=\"\"></p>\n<p>Learn more about <a href=\"https://nextjs.org/docs/app/building-your-application/routing/colocation\">Project Organization and Colocation</a>.</p>\n<h2>Server-Centric Routing with Client-side Navigation</h2>\n<p>Unlike the <code>pages</code> directory which uses client-side routing, the App Router uses <strong>server-centric routing</strong> to align with <a href=\"https://nextjs.org/docs/getting-started/react-essentials#server-components\">Server Components</a> and <a href=\"https://nextjs.org/docs/app/building-your-application/data-fetching/fetching\">data fetching on the server</a>. With server-centric routing, the client does not have to download a route map and <strong>the same request for Server Components can be used to look up routes</strong>. This optimization is useful for all applications, but has a larger impact on applications with many routes.</p>\n<p>Although routing is server-centric, the router uses <strong>client-side navigation</strong> with the <a href=\"https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#link-component\">Link Component</a> - resembling the behavior of a Single-Page Application. This means when a user navigates to a new route, the browser will not reload the page. Instead, the URL will be updated and Next.js will <a href=\"https://nextjs.org/docs/app/building-your-application/routing#partial-rendering\">only render the segments that change</a>.</p>\n<p>Additionally, as users navigate around the app, the router will store the result of the React Server Component payload in an <strong>in-memory client-side cache</strong>. The cache is split by route segments which allows invalidation at any level and ensures consistency across <a href=\"https://react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react\">React's concurrent renders</a>. This means that for certain cases, the cache of a previously fetched segment can be re-used, further improving performance.</p>\n<h2>Partial Rendering</h2>\n<p>When navigating between sibling routes (e.g. <code>/dashboard/settings</code> and <code>/dashboard/analytics</code> below), Next.js will only fetch and render the layouts and pages in routes that change. It will <strong>not</strong> re-fetch or re-render anything above the segments in the subtree. This means that in routes that share a layout, the layout will be preserved when a user navigates between sibling pages.</p>\n<p><img src=\"https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fpartial-rendering.png&#x26;w=1920&#x26;q=75\" alt=\"\"></p>\n<p>Without partial rendering, each navigation would cause the full page to re-render on the server. Rendering only the segment that’s updating reduces the amount of data transferred and execution time, leading to improved performance.</p>\n"},{"tags":[{"name":"javascript","id":"javascript-126409"},{"name":"promises","id":"promises-249930"}],"title":"Creating and Chaining Promises - A step by step guide","date":null,"description":"","slug":"creating-and-chaining-promises--a-step-by-step-guide","id":"creating-and-chaining-promises--a-step-by-step-guide-530610","content":"<p>In the previous article, we have learned about the basics of JavaScript Promises and how to create and use them to handle asynchronous operations in JavaScript. In this article, we will take a deeper dive into creating and chaining Promises and learn how to use them to build more complex and efficient applications.</p>\n<p>We will start by creating Promises using the <code>Promise</code> constructor. As we have seen in the first article, the <code>Promise</code> constructor takes a single argument, a function called the \"executor,\" which is called immediately when the Promise is created. The executor function is passed two arguments, a <code>resolve</code> function and a <code>reject</code> function, which can be used to indicate the success or failure of the asynchronous operation.</p>\n<p>Here is an example of a simple Promise that resolves with the message \"Hello, World!\" after 1 second:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myPromise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'Hello, World!'</span>);\n  }, <span class=\"hljs-number\">1000</span>);\n});\n</code></pre>\n<p>In this example, we are using the <code>setTimeout</code> function to simulate an asynchronous operation, and we are calling the <code>resolve</code> function after 1 second to indicate that the operation has completed successfully.</p>\n<p>We can also use the <code>reject</code> function to indicate that the asynchronous operation has failed. Here is an example of a Promise that rejects with an error message after 1 second:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myPromise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">'Something went wrong'</span>));\n  }, <span class=\"hljs-number\">1000</span>);\n});\n</code></pre>\n<p>In this example, we are using the <code>setTimeout</code> function to simulate an asynchronous operation, and we are calling the <code>reject</code> function after 1 second to indicate that the operation has failed.</p>\n<p>Once a Promise is created, we can use the <code>.then</code> method to attach a callback function that will be called when the Promise is resolved. We can also use the <code>.catch</code> method to attach a callback function that will be called when the Promise is rejected. Here is an example of using the <code>.then</code> and <code>.catch</code> methods to handle the results of the Promise:</p>\n<pre><code class=\"hljs language-js\">myPromise\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">message</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message))\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error));\n</code></pre>\n<p>In this example, we are using the <code>.then</code> method to attach a callback function that will log the message to the console when the Promise is resolved. We are also using the <code>.catch</code> method to attach a callback function that will log any errors to the console when the Promise is rejected.</p>\n<p>Chaining Promises together is another powerful feature of JavaScript Promises. We can chain Promises together by returning a new Promise from the callback function attached to the <code>.then</code> method. Here is an example of chaining two Promises together:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myPromise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'Hello, World!'</span>);\n  }, <span class=\"hljs-number\">1000</span>);\n});\n\nmyPromise\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">message</span> =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n        <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'Hello, Again!'</span>);\n      }, <span class=\"hljs-number\">1000</span>);\n    });\n  })\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">message</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message))\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error));\n</code></pre>\n<p>In this example, we are chaining two Promises together. The first Promise resolves with the message \"Hello, World!\" after 1 second, and the second Promise resolves with the message \"Hello, Again!\" after another 1 second. The second Promise is returned from the callback function attached to the <code>.then</code> method of the first Promise, allowing us to chain the two Promises together. This creates a more complex asynchronous workflow and allows us to handle the results of multiple asynchronous operations in a predictable and maintainable way.</p>\n<p>Additionally, we can also use the <code>Promise.all</code> method to handle multiple Promises in parallel. This method takes an array of Promises as an argument and returns a new Promise that resolves when all of the Promises in the array have resolved. Here is an example of using the <code>Promise.all</code> method:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> promise1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'Promise 1 resolved'</span>);\n  }, <span class=\"hljs-number\">1000</span>);\n});\n<span class=\"hljs-keyword\">const</span> promise2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'Promise 2 resolved'</span>);\n  }, <span class=\"hljs-number\">2000</span>);\n});\n\n<span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([promise1, promise2])\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">results</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(results))\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error));\n</code></pre>\n<p>In this example, we are creating two Promises, <code>promise1</code> and <code>promise2</code>, which resolve with different messages after different time intervals. We then pass these Promises in an array to the <code>Promise.all</code> method, which returns a new Promise that resolves when both of the Promises in the array have resolved. The <code>.then</code> callback function attached to the new Promise logs the results of both Promises to the console.</p>\n<p>In conclusion, creating and chaining Promises is an essential part of working with asynchronous operations in JavaScript. By understanding how to create and chain Promises, we can build more complex and efficient applications. Additionally, by using the <code>Promise.all</code> method, we can handle multiple Promises in parallel. In the next article, we will dive into error handling with Promises and learn how to handle rejections in a more robust way.</p>\n"},{"tags":[{"name":"javascript","id":"javascript-698740"},{"name":"promises","id":"promises-387973"}],"title":"Introduction to JavaScript Promises - Understanding the Basics","date":null,"description":"","slug":"introduction-to-javascript-promises--understanding-the-basics","id":"introduction-to-javascript-promises--understanding-the-basics-365780","content":"<p>JavaScript Promises are a powerful tool for handling asynchronous operations in JavaScript. They allow you to write code that is more readable, maintainable, and predictable, making it easier to handle complex, non-blocking tasks. In this tutorial series, we will explore the basics of JavaScript Promises and learn how to use them to build more robust and efficient applications.</p>\n<p>In this first article, we will cover the basics of JavaScript Promises and understand how they work. We will start by defining what a JavaScript Promise is and why they are useful. We will then move on to creating and using Promises, and learn how to chain them together to create complex asynchronous workflows.</p>\n<p><strong>A JavaScript Promise is an object that represents the eventual completion or failure of an asynchronous operation.</strong> It is a way to handle the results of an asynchronous operation, such as a network request, without blocking the execution of the rest of your code. Promises are useful because they allow you to write code that is more readable, maintainable, and predictable, making it easier to handle complex, non-blocking tasks.</p>\n<p>Promises are created using the <code>Promise</code> constructor, which takes a single argument, a function called the \"executor.\" The executor function is called immediately when the Promise is created, and it is passed two arguments: a resolve function and a reject function. The resolve function is used to indicate that the asynchronous operation has completed successfully, while the reject function is used to indicate that the asynchronous operation has failed.</p>\n<p>Here is an example of a simple Promise:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myPromise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'Hello, World!'</span>);\n  }, <span class=\"hljs-number\">1000</span>);\n});\n</code></pre>\n<p>In this example, we are creating a new Promise that will resolve with the message \"Hello, World!\" after 1 second. The <code>setTimeout</code> function is used to simulate an asynchronous operation.</p>\n<p>Once a Promise is created, you can use the <code>.then</code> method to attach a callback function that will be called when the Promise is resolved. The <code>.catch</code> method can be used to attach a callback function that will be called when the Promise is rejected.</p>\n<pre><code class=\"hljs language-js\">myPromise\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">message</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message))\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error));\n</code></pre>\n<p>In this example, we are using the <code>.then</code> method to attach a callback function that will log the message to the console when the Promise is resolved. We are also using the <code>.catch</code> method to attach a callback function that will log any errors to the console when the Promise is rejected.</p>\n<p>Promises can also be chained together to create complex asynchronous workflows. This is done by returning a new Promise from the callback function attached to the <code>.then</code> method.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myPromise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'Hello, World!'</span>);\n  }, <span class=\"hljs-number\">1000</span>);\n});\n\nmyPromise\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">message</span> =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n        <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">'Hello, Again!'</span>);\n      }, <span class=\"hljs-number\">1000</span>);\n    });\n  })\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">message</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message))\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error));\n</code></pre>\n<p>In this example, we are chaining two Promises together. The first Promise resolves with the message \"Hello, World!\" after 1 second, and the second Promise resolves with the message \"Hello, Again!\" after another 1 second. The second Promise is returned from the callback function attached to the <code>.then</code> method of the first Promise, allowing us to chain the two Promises together.</p>\n<p>In conclusion, JavaScript Promises are a powerful tool for handling asynchronous operations in JavaScript. They allow you to write code that is more readable, maintainable, and predictable, making it easier to handle complex, non-blocking tasks. In this first article, we have covered the basics of JavaScript Promises, including how to create and use them, and how to chain them together to create complex asynchronous workflows.</p>\n<p>In the next articles of this tutorial series, we will explore more advanced topics such as error handling, parallel and sequential execution, and cleaning up resources with Promises. We will also look at some of the built-in methods available on the Promise prototype, such as <code>Promise.all</code>, <code>Promise.race</code>, <code>Promise.resolve</code>, <code>Promise.reject</code>, <code>Promise.prototype.then</code>, <code>Promise.prototype.catch</code>, and <code>Promise.prototype.finally</code>. Stay tuned!</p>\n"},{"title":"Learn Express Routes","date":null,"description":"","slug":"learn-express-routes","id":"learn-express-routes-448941","tags":[],"content":"<h2>Introduction</h2>\n<p>A huge portion of the internet's data travels over HTTP/HTTPS through request-response cycles between client and servers. Every time that you use a website, your browser sends requests to one or many servers requesting resources. Every image, meme, post, and video is requested by a client and sent in a response from a server.</p>\n<p>Express is a powerful but flexible Javascript framework for creating web servers and APIs. It can be user for everything from simple file servers to JSON APIs to full production servers.</p>\n<p>In this lesson, You will be learning all the necessary skills to implement an API allowing clients to Create, Read, Update and Delete Expressions. These four functionalities together are known as CRUD, and they form the backbone of many real-life APIs.</p>\n<h2>Starting a Server</h2>\n<p>Express is a node module, so in order to use it, we will need to import it in our program file. To create a server, the imported <code>express</code> function must be invoked.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// import the express module</span>\n<span class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"express\"</span>)\n<span class=\"hljs-comment\">// create an instance of an Express application</span>\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>()</code></pre>\n<p>On the first line, we import the Express library with <code>require</code>. When invoked on the second line, it returns an instance of an Express application. This application can be used to start a server and specifiy server behavior.</p>\n<p>The purpose of a server is to listen for requests, perform whatever action is required to satisfy the request, and then return a response.</p>\n<p>In order for our server to start responding, we have to tell the server where to <em>listen</em> for new requests by providing a port number argument to a method called <code>app.listen()</code>. The server will then listen on the specified <code>port</code> and respond to any requests that come into it.</p>\n<p>The second argument is a callback function that will be called once the server is running and ready to receive responses.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PORT</span> = <span class=\"hljs-number\">4001</span>\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-variable constant_\">PORT</span>, <span class=\"hljs-function\">() =></span> {\n\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Server is running on port <span class=\"hljs-subst\">${PORT}</span>`</span>)\n})</code></pre>\n<p>In this example, our <code>app.listen()</code> call will start a server listening on port <code>4001</code>, and once the server is started it will log <code>'Server is listening on port 4001'</code></p>\n<h2>Writing Your First Route</h2>\n<p>Once the Express server is listening, it can respond to any and all requests. But how does it know what to do with these requests? To tell our server how to deal with any given request, we register a series of <em>routes</em>. Routes define the control flow for requests based on the request's <em>path</em> and HTTP verb.</p>\n<p>For example, if your server receives a GET request at <code>/monsters</code>, we will use a route to define the appropriate functionality for that HTTP verb (GET) and path (<code>monsters</code>).</p>\n<p>The HTTP verb is always included in the request, and it is one of a finite number of options used to specify expected functionality. GET requests are used for retrieving resources from a server, and we will discuss additional request types in later exercises.</p>\n<p>Express uses <code>app.get()</code> to register routes to match <code>GET</code> requests. Express routes (including <code>app.get()</code>) usually take two arguments, a path (usually a string), and a callback function to handle the request and send a response.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> moods = [\n\t{mood : <span class=\"hljs-string\">'excited about express!'</span>},\n\t{mood : <span class=\"hljs-string\">'route-tastic'</span>}\n]\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"/moods\"</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, res, next</span>) =></span> {\n\t<span class=\"hljs-comment\">// Here we would send back the moods array in response</span>\n})</code></pre>\n<p>The route above will match any <code>GET</code> request to <code>'/moods'</code> and call the callback function, passing in two objects as the first two arguments. These objects represent the request sent to the server and the response that the Express server should eventually send to the client.</p>\n<p>If no routes are matched on a client request, the Express server will handle sending a 404 Not Found response to the client.</p>\n<h2>Sending a Response</h2>\n<p>HTTP follows a one request-one response cycle. Each client expects exactly one response per request, and each server should only send a single response back to the client per request. The client is like a customer at a restaurent ordering a large bowl of cup: the request is sent through the wait staff, the kithcen prepares the soup, and after it is prepared, the wait staff returns it to the customer. In the restaurent, it would be unfortunate if the soup never arrived back to the customer, but it would be equally problematic if the customer was given four large bowls of soup and was asked to consume them all at the exact time. That's impossible with only two hands!</p>\n<p>Express servers send responses using the <code>.send()</code> method on the response object. <code>.send()</code> will take any input and include it into the response body.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> monsters = [\n\t{...},\n\t{...}\n]\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"/monsters\"</span>, <span class=\"hljs-function\">() =></span> {\n\tres.<span class=\"hljs-title function_\">send</span>(monsters)\n})</code></pre>\n<p>In this example, a <code>GET /monsters</code> request will match the route, Express will call the callback function, and the <code>res.send()</code> method will send back an erray of spooky monsters.</p>\n<p>In addition to <code>.send()</code>, <code>.json()</code> can be used to explicitly send JSON-formatted responses. <code>.json()</code> sends any Javascript object passed into it.</p>\n"},{"title":"How to create custom hooks in react","date":null,"description":"","slug":"how-to-create-custom-hooks-in-react","id":"how-to-create-custom-hooks-in-react-29292","tags":[{"name":"react","id":"react-432001"},{"name":"react-hooks","id":"react-hooks-68293"}],"content":"<h2>Demo Article</h2>\n<h3>Heading 3</h3>\n<h4>Heading 4</h4>\n<h5>Heading 5</h5>\n<h6>Heading 6</h6>\n"},{"title":"Tutorial on reading a file in Nodejs","date":"2023-06-01 05:20","tags":[{"name":"nodejs","id":"nodejs-43521"},{"name":"javascript","id":"javascript-73097"}],"description":"","slug":"reading-a-file-in-nodejs","id":"tutorial-on-reading-a-file-in-nodejs-741758","content":"<h2>Introduction</h2>\n<p>In this tutorial, we will cover reading a file in Node.js using different approaches, including synchronous and asynchronous methods. We will discuss the use of <code>fs</code> module, which is a built-in module for handling file system operations in Node.js.</p>\n<h2>Synchronous Reading</h2>\n<p>The <code>fs.readFileSync</code> function is used for synchronous reading a file. It takes two arguments: the file path and the character encoding. If you do not provide the character encoding, the output will be shown as a buffer. Here is an example:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"fs\"</span>)\n<span class=\"hljs-keyword\">const</span> textRead = fs.<span class=\"hljs-title function_\">readFileSync</span>(<span class=\"hljs-string\">\"./text/readFile.txt\"</span>, <span class=\"hljs-string\">'utf-8'</span>)\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(textRead)</code></pre>\n<p>In this example, we import the <code>fs</code> module and read a file located in the same directory in the <code>text</code> folder with the name <code>readfile.txt</code>. The <code>readFileSync</code>  returns the content of the file, which we save in the <code>textRead</code> variable and then print to the console.</p>\n<h2>Asynchronous Reading</h2>\n<p>For asynchronous reading, you can use the <code>fs.readFile()</code> method, which takes the file path, encoding, and a callback function that will be called with the file data and (and the error):</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"fs\"</span>)\nfs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">\"./text/readfile.txt\"</span>, <span class=\"hljs-string\">\"utf-8\"</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err, data</span>) =></span> {\n\t<span class=\"hljs-keyword\">if</span> (err) {\n\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err)\n\t<span class=\"hljs-keyword\">return</span>\n\t}\n\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data)\n} )</code></pre>\n<p>In this example, we use the <code>fs.readFile()</code> function to read the same file as before. The callback function is called with the file data and an error object. If there is an error, we log it to the console. Otherwise, we print the file data to the console.</p>\n<h2>Promises</h2>\n<p>For a more modern approach, you can use the promise-based <code>fs.promises.readFile()</code> method or streams to read the file content.  This is especially useful when dealing with large files, as it helps to avoid consuming too much memory and impacting the speed of execution.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"fs\"</span>).<span class=\"hljs-property\">promises</span>\nfs.<span class=\"hljs-title function_\">readFile</span>(<span class=\"hljs-string\">\"./text/readfile.txt\"</span>, <span class=\"hljs-string\">'utf-8'</span>)\n.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =></span> {\n\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data)\n})\n.<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> {\n\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err)\n})</code></pre>\n<p>In this example, we use the <code>fs.promises.readFile()</code> method to read the file asynchronously. The function returns a promise that resolves with the file data. We use the <code>then()</code> method to handle the resolved promise and print the file data to the console. If there is an error, we handle it using the <code>catch()</code> method.</p>\n<h2>Conclusion</h2>\n<p>To sum up, you can read a file in Node.js using different  approaches like synchronous (<code>fs.readFileSync()</code>), asynchronous (<code>fs.readFile()</code>) , promise-based (f<code>fs.promises.readFile()</code>), and streams. Each approach has its own pros and cons, so choose the one that fits your specific use case.</p>\n"},{"tags":[{"name":"svelte","id":"svelte-26957"}],"title":"Bindings in Svelte","date":null,"description":"","slug":"bindings-in-svelte","id":"bindings-in-svelte-150802","content":"<h2>Text Inputs</h2>\n<p>As a general rule, data flow in svelte is <em>top down</em> - a parent component can set props on a child component, and a component can set attributes  on an element, but not the other way around.</p>\n<p>Sometimes it is useful to break that rule.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">'world'</span>;\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{name}</span>></span>\n   \n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>Hello {name}!<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span></code></pre>\n<p>Take the case of the <code>&#x3C;input></code> element in the component - we could add an <code>on:input</code> event handler that sets the value of <code>name</code> to <code>event.target.value</code>, but it is a bit... biolerplatey. It gets even worse with other form elements.</p>\n<p>Instead, we can use the <code>bind:value</code> directive:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{name}</span>></span></code></pre>\n<p>This means that not only will changes to the value of <code>name</code> update the input value, but changes to the input value will update <code>name</code>.</p>\n<p>However, <code>bind:value</code> directive only updates the variable when the input element loses focus, so the <code>on:input</code> listener ensures that changes to the input element are immediately reflected in the variable.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{name}</span> <span class=\"hljs-attr\">on:input</span>=<span class=\"hljs-string\">{handleChange}</span> ></span></code></pre>\n<p><code>bind:value</code> is a powerful feature of Svelte that makes it easy to create two-way data bindings between variables and input elements, allowing for dyanamic and reactive user interfaces.</p>\n<h2>Numeric Inputs</h2>\n<p>In the DOM, everything is a string. That's unhelpful when you are dealing with numeric inputs - <code>type=\"number\"</code> and <code>type=\"range\"</code> - as it means you have to remember to coerce <code>input.value</code> before using it.</p>\n<p>With <code>bind:value</code>, Svelte takes care of it for you:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">number</span> <span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{a}</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">0</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">10</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">range</span> <span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{a}</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">0</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">10</span>></span></code></pre>\n<h2>Checkbox inputs</h2>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">let</span> yes = <span class=\"hljs-literal\">false</span>;\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">checkbox</span> <span class=\"hljs-attr\">checked</span>=<span class=\"hljs-string\">{yes}</span>></span>\n\tYes! Send me regular email spam\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n{#if yes}\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>Thank you. We will bombard your inbox and sell your personal details.<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n{:else}\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>You must opt-in to continue. If you're not paying, you're the product.<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n{/if}\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{!yes}</span>></span>\n\tSubscribe\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></code></pre>\n<p>Checkboxes are used for toggling between states. Instead of binding to <code>input:value</code>, we bind to <code>input:checked</code>:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">checkbox</span> <span class=\"hljs-attr\">bind:checked</span>=<span class=\"hljs-string\">{yes}</span>></span></code></pre>\n<h2>Group Inputs</h2>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">let</span> scoops = <span class=\"hljs-number\">1</span>;\n\t<span class=\"hljs-keyword\">let</span> flavours = [<span class=\"hljs-string\">'Mint choc chip'</span>];\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h2</span>></span>Size<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h2</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">radio</span> <span class=\"hljs-attr\">group</span>=<span class=\"hljs-string\">{scoops}</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"scoops\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{1}</span>></span>\n\tOne scoop\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">radio</span> <span class=\"hljs-attr\">group</span>=<span class=\"hljs-string\">{scoops}</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"scoops\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{2}</span>></span>\n\tTwo scoops\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">radio</span> <span class=\"hljs-attr\">group</span>=<span class=\"hljs-string\">{scoops}</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"scoops\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{3}</span>></span>\n\tThree scoops\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h2</span>></span>Flavours<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h2</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">checkbox</span> <span class=\"hljs-attr\">group</span>=<span class=\"hljs-string\">{flavours}</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"flavours\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Cookies and cream\"</span>></span>\n\tCookies and cream\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">checkbox</span> <span class=\"hljs-attr\">group</span>=<span class=\"hljs-string\">{flavours}</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"flavours\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Mint choc chip\"</span>></span>\n\tMint choc chip\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">checkbox</span> <span class=\"hljs-attr\">group</span>=<span class=\"hljs-string\">{flavours}</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"flavours\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Raspberry ripple\"</span>></span>\n\tRaspberry ripple\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n\n</code></pre>\n<p>If you have multiple inputs relating to the same value, you can use <code>bind:group</code> along with the <code>value</code> attribute. Radio inputs in the same group are mutually exclusive; checkbox inputs in the same group form an array of selected values.</p>\n<p>Add <code>bind:group</code> to each input:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">radio</span> <span class=\"hljs-attr\">bind:group</span>=<span class=\"hljs-string\">{scoops}</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"scoops\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{1}</span>></span></code></pre>\n<p>In this case, we could make the code simpler by moving the checkbox inputs into an <code>each</code> block. First, add a <code>menu</code> variable to the <code>&#x3C;script></code> block...</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> menu = [\n\t<span class=\"hljs-string\">'Cookies and cream'</span>,\n\t<span class=\"hljs-string\">'Mint choc chip'</span>,\n\t<span class=\"hljs-string\">'Raspberry ripple'</span>\n];</code></pre>\n<p>...then replace the second section:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h2</span>></span>Flavours<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h2</span>></span>\n\n{#each menu as flavour}\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">label</span>></span>\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">checkbox</span> <span class=\"hljs-attr\">bind:group</span>=<span class=\"hljs-string\">{flavours}</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"flavours\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{flavour}</span>></span>\n\t\t{flavour}\n\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span>\n{/each}</code></pre>\n<p>It is now easy to expand our icecream menu in new and exciting directions.</p>\n<h2>Textarea Inputs</h2>\n<p>The <code>&#x3C;textarea></code> element behaves similarly to a text input in Svelte - use <code>bind:value</code> to create a two-way binding between the <code>&#x3C;textarea></code> content and the <code>value</code> varaible:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{value}</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">textarea</span>></span></code></pre>\n<p>In cases like these, where the names match, we can also use a shorthand form:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">bind:value</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">textarea</span>></span></code></pre>\n<p>This applies to all bindings, not just textareas.</p>\n<h2>Select Bindings</h2>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">let</span> questions = [\n\t\t{ <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">`Where did you go to school?`</span> },\n\t\t{ <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">`What is your mother's name?`</span> },\n\t\t{ <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">`What is another personal fact that an attacker could easily find with Google?`</span> }\n\t];\n\t<span class=\"hljs-keyword\">let</span> selected;\n\t<span class=\"hljs-keyword\">let</span> answer = <span class=\"hljs-string\">''</span>;\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleSubmit</span>(<span class=\"hljs-params\"></span>) {}\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h2</span>></span>Insecurity questions<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h2</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">on:submit</span>|<span class=\"hljs-attr\">preventDefault</span>=<span class=\"hljs-string\">{handleSubmit}</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{selected}</span> <span class=\"hljs-attr\">on:change</span>=<span class=\"hljs-string\">\"{() => answer = ''}\"</span>></span>\n\t\t{#each questions as question}\n\t\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{question}</span>></span>\n\t\t\t\t{question.text}\n\t\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">option</span>></span>\n\t\t{/each}\n\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">select</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{answer}</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">{!answer}</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">submit</span>></span>\n\t\tSubmit\n\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">form</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>selected question {selected ? selected.id : '[waiting...]'}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span></code></pre>\n<p>We can also use <code>bind:value</code> with <code>&#x3C;select></code> elements.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{selected}</span> <span class=\"hljs-attr\">on:change</span>=<span class=\"hljs-string\">\"{() => answer = ''}\"</span>></span></code></pre>\n<p>Note that <code>&#x3C;option></code> values are objects rather than strings. Svelte does not mind.</p>\n<blockquote>\n<p>Because we haven't set an initial value of <code>selected</code>, the binding will set it to the default value (the first in the list) automatically. Be careful though — until the binding is initialised, <code>selected</code> remains undefined, so we can't blindly reference e.g. <code>selected.id</code> in the template. If your use case allows it, you could also set an initial value to bypass this problem.</p>\n</blockquote>\n<h2>Select Multiple</h2>\n<p>A select can have a <code>multiple</code> attribute, in which case it will populate an array rather than selecting a single value.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h2</span>></span>Flavours<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h2</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">multiple</span> <span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{flavours}</span>></span>\n\t{#each menu as flavour}\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">{flavour}</span>></span>\n\t\t\t{flavour}\n\t\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">option</span>></span>\n\t{/each}\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">select</span>></span></code></pre>\n<h2>Contenteditable bindings</h2>\n<p>Elements with <code>contenteditable=true</code> attribute support <code>textContent</code> and <code>innerHTML</code> bindings:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>\n\t<span class=\"hljs-attr\">contenteditable</span>=<span class=\"hljs-string\">\"true\"</span>\n\t<span class=\"hljs-attr\">bind:innerHTML</span>=<span class=\"hljs-string\">{html}</span>\n\t<span class=\"hljs-attr\">bind:textContent</span>=<span class=\"hljs-string\">{text}</span>\n></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></code></pre>\n<h2>Each block bindings</h2>\n<p>You can even bind to properties inside an <code>each</code> block.</p>\n<pre><code class=\"hljs language-html\">{#each todos as todo}\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class:done</span>=<span class=\"hljs-string\">{todo.done}</span>></span>\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span>\n\t\t\t<span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">checkbox</span>\n\t\t\t<span class=\"hljs-attr\">bind:checked</span>=<span class=\"hljs-string\">{todo.done}</span>\n\t\t></span>\n\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span>\n\t\t\t<span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"What needs to be done?\"</span>\n\t\t\t<span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{todo.text}</span>\n\t\t></span>\n\t<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n{/each}</code></pre>\n<blockquote>\n<p>Note that interacting with these <code>&#x3C;input></code> elements will mutate the array. If you prefer to work with immutable data, you should avoid these bindings and use event handlers instead.</p>\n</blockquote>\n<h2>Media elements</h2>\n<p>The <code>&#x3C;audio></code> and <code>&#x3C;video></code> elments have several properties that you can bind to.</p>\n<pre><code>&#x3C;video\n\tposter=\"https://sveltejs.github.io/assets/caminandes-llamigos.jpg\"\n\tsrc=\"https://sveltejs.github.io/assets/caminandes-llamigos.mp4\"\n\ton:mousemove={handleMove}\n\ton:touchmove|preventDefault={handleMove}\n\ton:mousedown={handleMousedown}\n\ton:mouseup={handleMouseup}\n\tbind:currentTime={time}\n\tbind:duration\n\tbind:paused>\n\t&#x3C;track kind=\"captions\">\n&#x3C;/video>\n</code></pre>\n<blockquote>\n<p>Ordinarily on the web, you would track <code>currentTime</code> by listening for <code>timeupdate</code> events. But these events fire too infrequently, resulting in choppy UI. Svelte does better — it checks <code>currentTime</code> using <code>requestAnimationFrame</code></p>\n</blockquote>\n<p>The complete set of bindings for <code>&#x3C;audio></code> and <code>&#x3C;video></code> is as follows — six <em>readonly</em> bindings...</p>\n<ul>\n<li><code>duration</code> (readonly) — the total duration of the video, in seconds</li>\n<li><code>buffered</code> (readonly) — an array of <code>{start, end}</code> objects</li>\n<li><code>seekable</code> (readonly) — ditto</li>\n<li><code>played</code> (readonly) — ditto</li>\n<li><code>seeking</code> (readonly) — boolean</li>\n<li><code>ended</code> (readonly) — boolean</li>\n</ul>\n<p>...and five <em>two-way</em> bindings:</p>\n<ul>\n<li><code>currentTime</code> — the current point in the video, in seconds</li>\n<li><code>playbackRate</code> — how fast to play the video, where <code>1</code> is 'normal'</li>\n<li><code>paused</code> — this one should be self-explanatory</li>\n<li><code>volume</code> — a value between 0 and 1</li>\n<li><code>muted</code> — a boolean value where true is muted</li>\n</ul>\n<p>Videos additionally have readonly <code>videoWidth</code> and <code>videoHeight</code> bindings.</p>\n<h2>Dimensions</h2>\n<p>Every block-level element has <code>clientWidth</code>, <code>clientHeight</code>, <code>offsetWidth</code>, and <code>offsetHeight</code> bindings:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">bind:clientWidth</span>=<span class=\"hljs-string\">{w}</span> <span class=\"hljs-attr\">bind:clientHeight</span>=<span class=\"hljs-string\">{h}</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"font-size: {size}px\"</span>></span>{text}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">span</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></code></pre>\n<p>These bindings are readonly — changing the values of <code>w</code> and <code>h</code> won't have any effect.</p>\n<h2>This</h2>\n<p>The readonly <code>this</code> binding applies to every element (and component) and allows you to obtain a reference to rendered elements. For example, we can get a reference to a <code>&#x3C;canvas></code> element:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">canvas</span>\n\t<span class=\"hljs-attr\">bind:this</span>=<span class=\"hljs-string\">{canvas}</span>\n\t<span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">{32}</span>\n\t<span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">{32}</span>\n></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">canvas</span>></span></code></pre>\n<p>Note that the value of <code>canvas</code> will be <code>undefined</code> until the component has mounted, so we must put the logic inside the <code>onMount</code> lifecycle function.</p>\n<h2>Component bindings</h2>\n"},{"tags":[{"name":"svelte","id":"svelte-476518"}],"title":"Explain onMount in svelte with examples","date":null,"description":"","slug":"explain-onmount-in-svelte-with-examples","id":"explain-onmount-in-svelte-with-examples-516235","content":"<p><code>onMount</code> is a lifecycle function in Svelte that is called when a component is first mounted to the DOM. It is often used to perform initial step, such as fetching data or setting up event listeners.</p>\n<p>Here is an example of using <code>onMount</code> to fetch data from an API:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> {onMount} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'svelte'</span>;\n\t<span class=\"hljs-keyword\">let</span> data = []\n\t<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\"></span>){\n\t\t<span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">\"https://example.com/api/data\"</span>)\n\t\tdata = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>()\n\t}\n<span class=\"hljs-title function_\">onMount</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">fetchData</span>())\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ul</span>></span>\n{#each data as item}\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">li</span>></span>{item}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">li</span>></span>\n{/each}\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ul</span>></span></code></pre>\n<p>In this example. <code>onMount</code> is used to call the <code>fetchData</code> function, which makes a request to an API and sets the <code>data</code> variable to the response. The data is then rendered in the <code>ul</code> element using a <code>#each</code> block.</p>\n<p>Here is another example of using <code>onMount</code> to set up an event listener:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> {onMount} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'svelte'</span>\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleResize</span>(<span class=\"hljs-params\"></span>) {\n\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Window resized\"</span>)\n\t}\n\t<span class=\"hljs-title function_\">onMount</span>(<span class=\"hljs-function\">() =></span> {\n\t\t<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">\"resize\"</span>, handleResize)\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> {\n\t\t\t<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">\"resize\"</span>, handleResize)\n\t\t}\n\t})\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></code></pre>\n<p>In this example, <code>onMount</code> is used to add an event listener to the <code>window</code> object for the <code>resize</code> event. The <code>handleResize</code> function is called whenever the window is resized, and logs a message to the console. The <code>return</code> statement in the <code>onMount</code> function is used to clean up the event listener when the component is unmounted. This is important to prevent leaks in the application.</p>\n"},{"tags":[{"name":"svelte","id":"svelte-740748"}],"title":"Getting started with Svelte","date":null,"description":"","slug":"getting-started-with-svelte","id":"getting-started-with-svelte-210905","content":"<h2>Introduction to Svelte</h2>\n<p>Svelte is a relatively new frontend JavaScript framework. Svelte is different from other popular frameworks like React, Angular, and Vue.js in that it is a compiler, not a runtime library. This means that instead of sending code to the client and having it run there, Svelte compiles your components into efficient JavaScript code that runs directly in the browser.</p>\n<p>Svelte has several advantages:</p>\n<ol>\n<li>Firstly, it is fast and lightweight. Because Svelte compiles your components into efficient JavaScript, your application will run quickly and smoothly.</li>\n<li>Secondly, it has a small learning curve compared to other frontend frameworks.</li>\n<li>Finally, Svelte has a growing and supportive community.</li>\n</ol>\n<h2>Setting up your development environment</h2>\n<p>To use Svelte, you will need to have Node.js and npm (node package manager) installed on your computer. Node.js is a JavaScript runtime environment, and npm is a package manager that helps you install and manage packages for your projects.</p>\n<p>To create a new Svelte project using npx:</p>\n<pre><code>npx degit sveltejs/template my-svelte-project\ncd my-svelte-project\nnpm install\nnpm run dev\n</code></pre>\n<p><code>npx</code> is a tool that allows you to execute npm packages, and <code>digit</code> is a package that allows you to clone and bootstrap a repository without Git. <code>sveltejs/template</code> is the repository that contains the Svelte project template, and <code>my-svelte-project</code> is the name of the directory that will be created for your new project.</p>\n<p><code>npm run</code> is a command that allows you to run scripts defined in the <code>scripts</code> section of your project's <code>package.json</code> file. <code>dev</code> is the name of the script that starts the development server.</p>\n<p>After running <code>npm run dev</code>, Svelte will compile and build your application. It will start a local server. Svelte will watch for file updates, and automatically recompile and refresh the app for you when changes are made to the source files.</p>\n<h2>Application Structure</h2>\n<p>The starter template comes with the following structure:</p>\n<pre><code>my-svelte-project\n├── README.md\n├── package.json\n├── package-lock.json\n├── rollup.config.js\n├── .gitignore\n├── node_modules\n├── public\n│   ├── favicon.png\n│   ├── index.html\n│   ├── global.css\n│   └── build\n│       ├── bundle.css\n│       ├── bundle.js\n│       └── bundle.js.map\n├── scripts\n│   └── setupTypeScript.js\n└── src\n    ├── App.svelte\n    └── main.js\n</code></pre>\n<p>The contents are as follows:</p>\n<ul>\n<li><code>rollup.config.js</code>:  Svelte uses <code>rollup.js</code> as a module bundler. This configuration file tells rollup how to compile and build your app. If your prefer <code>webpack</code>, you can create your starter project with <code>npx degit sveltejs/template-webpack</code></li>\n<li><code>src</code>: This directory is where the source code for your application lives - where you will be creating the code for your app.\n<ul>\n<li><code>App.svelte</code> - This is the top-level component of your app.</li>\n<li><code>main.js</code> - The entry point to our application. It just instantiate the <code>App</code> component and binds it to the body of our HTML page.</li>\n</ul>\n</li>\n<li><code>public</code>: This directory contains all the filles that will be published in production.\n<ul>\n<li><code>index.html</code>: This is the main page of our app. Initially it is just an empty HTML page that loads the CSS files and js bundles generated by Svelte.</li>\n<li><code>global.css</code>: This file contains unscoped styles. It is a regular CSS file that will be applied to the whole application.</li>\n<li><code>build</code>: This folder contains the generated CSS and JavaScript source code.</li>\n</ul>\n</li>\n</ul>\n<h2>Having a look at our first Svelte component</h2>\n<p>Components are the building blocks of Svelte applications. They are written into <code>.svelte</code> files using a superset of HTML.</p>\n<p>All there sections - <code>&#x3C;script></code>, <code>&#x3C;style></code>, and markup - are optional, and can appear in any order you like.</p>\n<pre><code>&#x3C;script>\n  // logic goes here\n&#x3C;/script>\n\n&#x3C;style>\n  /* styles go here */\n&#x3C;/style>\n\n&#x3C;!-- markup (zero or more HTML elements) goes here -->\n\n</code></pre>\n<h3>The <code>&#x3C;script></code> section</h3>\n<p>The <code>&#x3C;script></code> block contains JavaScript that runs when a component instance is created. Variables declared (or imported) at the top level are 'visible' from the component's markup. Top-level variables are the way Svelte handles the component state, and they are reactive by default.</p>\n<pre><code>&#x3C;script>\n  export let name;\n&#x3C;/script>\n</code></pre>\n<p>Svelte uses the <code>export</code> keyword to mark a variable declaration as a property (or prop), which means it becomes accessible to consumers of the component (eg. other components).</p>\n<h3>The markup section</h3>\n<p>In the markup section you can insert any HTML you like, and in addition you can insert valid JavaScript expressions inside singly curly brackets (<code>{ }</code>).  In this case we are embedding the value of the <code>name</code> prop right after the <code>Hello</code> text.</p>\n<pre><code>&#x3C;main>\n  &#x3C;h1>Hello {name}!&#x3C;/h1>\n&#x3C;/main>\n</code></pre>\n<p>Svelte also supports tags like <code>{#if}</code>, <code>{#each}</code>, and <code>{#await}</code> - these directives or tags allow you to conditionally render a portion of the markup, iterate through a list of elements, and work with async values, respectively.</p>\n<h3>The <code>&#x3C;style></code> section</h3>\n<p>In Svelte, CSS inside a component's <code>&#x3C;style></code> block will be scoped only to that component. This works by adding a class to selected elements, which is based on a hash of the component styles.</p>\n<pre><code>&#x3C;h1 class=\"svelte-1tky8bj\">\n</code></pre>\n<blockquote>\n<p>You can override this behavior and apply styles to a selector globally using the <code>:global()</code> modifier.</p>\n</blockquote>\n<h2>A first look at Svelte reactivity</h2>\n<p>In the context of a UI framework, reactivity means that the framework can automatically update the DOM when the state of any component is changed.</p>\n<p>In Svelte, reactivity is triggered by assigning a new value to any top-level variable in a component. For example, we could include a <code>toggleName</code> function in our <code>App</code> component, and a button to run it.</p>\n<pre><code>&#x3C;script>\n  export let name;\n\n  function toggleName() {\n    if (name === \"world\") {\n      name = \"Svelte\";\n    } else {\n      name = \"world\";\n    }\n  }\n&#x3C;/script>\n\n&#x3C;main>\n  &#x3C;h1>Hello {name}!&#x3C;/h1>\n  &#x3C;button on:click=\"{toggleName}\">Toggle name&#x3C;/button>\n&#x3C;/main>\n</code></pre>\n<p>Whenever the button is clicked, Svelte executes the <code>toggleName()</code> function, which in turn updates the value of the <code>name</code> variable.</p>\n<p>The <code>&#x3C;h1></code> label is automatically updated. Behind the scenes, Svelte created the JavaScript code to update the DOM whenever the value of the name variable changes, without using any virtual DOM or other complex reconciliation mechanism.</p>\n<p>Note the use of <code>:</code> in <code>on:click</code> That's Svelte's syntax for listening to DOM events.</p>\n<h2>Inspecting <code>main.js</code>: the entry point on our app</h2>\n<p>Let's open <code>src/main.js</code>, which is where the <code>App</code> component is being imported and used. This file is the entry point for our app, and it initially looks like this:</p>\n<pre><code>import App from \"./App.svelte\";\n\nconst app = new App({\n  target: document.body,\n  props: {\n    name: \"world\",\n  },\n});\n\nexport default app;\n\n</code></pre>\n<p><code>main.js</code> starts by importing the Svelte component that we are going to use. Then, it instantiates it, passing an option object with the following properties:</p>\n<ul>\n<li><code>target</code>: The DOM element inside which we want the component to be rendered, in this case the <code>&#x3C;body></code> element.</li>\n<li><code>props</code>: the values to assign to each prop of the <code>App</code> component.</li>\n</ul>\n<h2>A look under the hood</h2>\n<p>How does Svelte manage to make all these files work together nicely?</p>\n<p>The Svelte compiler processes the <code>&#x3C;style></code> section of every component and compiles them into the <code>public/build/bundle.css</code> file.</p>\n<p>It also compiles the markup and <code>&#x3C;script></code> section of every component and stores that result in <code>public/build/bundle.js</code>. It also adds the code in <code>src/main.js</code> to reference the features of every component.</p>\n<p>Finally the file <code>public/index.html</code> includes the generated <code>bundle.css</code> and <code>bundle.js</code> files.</p>\n<h2>Conditional Statement</h2>\n<p>In Svelte, you can create conditional statement using the <code>{#if}</code> directive. The syntax is as follows:</p>\n<pre><code>{#if condition}\n\t&#x3C;!---HTML ---->\n{/if}\n</code></pre>\n<p>You can also use an <code>{else}</code> block to specify what to do if the condition  is not met:</p>\n<pre><code>{#if condition}\n\n{:else if condition}\n\n{:else}\n  \n{/if}\n</code></pre>\n<h2>Loop through an Array</h2>\n<p>In Svelte, you can create a <code>foreach</code> loop using the <code>{#each}</code> directive. The syntax is as follows:</p>\n<pre><code>{#each array as item (index)}\n  &#x3C;!-- code to be executed for each item in the array -->\n{/each}\n\n</code></pre>\n<p>For example:</p>\n<pre><code>&#x3C;script>\n  let numbers = [1, 2, 3, 4, 5];\n&#x3C;/script>\n\n&#x3C;ul>\n  {#each numbers as number (index)}\n    &#x3C;li>{index + 1}. {number}&#x3C;/li>\n  {/each}\n&#x3C;/ul>\n\n</code></pre>\n<p>In the above example, <code>number</code> is the current item in the <code>numbers</code> array, and <code>index</code> as its index. The <code>(index)</code> syntax is optional, and you can omit it if you do not need it in your loop.</p>\n<h2>Loop through an Object</h2>\n<p>In Svelte, you can loop through an object using the <code>{#each}</code> directive in a similar way as with arrays. However, since objects don't have a guaranteed order, you will need to extract the object's keys first, and then use those keys to access the values. Here is an example:</p>\n<pre><code>&#x3C;script>\n  let person = {\n    name: 'John Doe',\n    age: 30,\n    city: 'New York'\n  };\n&#x3C;/script>\n\n&#x3C;ul>\n  {#each Object.keys(person) as key}\n    &#x3C;li>{key}: {person[key]}&#x3C;/li>\n  {/each}\n&#x3C;/ul>\n\n</code></pre>\n<p>In the above example, <code>Object.keys(person)</code> returns an array of the object's keys, which we can then use in the <code>{#each}</code> loop to access the values.</p>\n"},{"tags":[{"name":"svelte","id":"svelte-958432"}],"title":"Lifecycle in Svelte","date":null,"description":"","slug":"lifecycle-in-svelte","id":"lifecycle-in-svelte-124683","content":"<h2>onMount</h2>\n<p>Every component has a <em>lifecyle</em> that starts when it is created, and ends when it is destroyed. There are a handful of functions that allow you to run code at key moments during that lifecycle.</p>\n<p>The one you will use most frequently is <code>onMount</code>, which runs after the component is first rendered to the DOM.</p>\n<p>We will add an <code>onMount</code> handler that loads some data over the network:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> {onMount} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'svelte'</span>\n\t<span class=\"hljs-keyword\">let</span> photos = []\n\t<span class=\"hljs-title function_\">onMount</span>(aysnc () => {\n\t\t<span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">\"/tutorial/api/album\"</span>)\n\t\tphotos = <span class=\"hljs-keyword\">await</span> res.<span class=\"hljs-title function_\">json</span>()\n\t})\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></code></pre>\n<p>It is recommended to put the <code>fetch</code> in <code>onMount</code> rather than at the top level of the <code>&#x3C;script></code> because of the server-side rendering (SSR). With the exception of <code>onDestroy</code>, lifecycle functions do not run during SSR, which means we can avoid fetching data that should be loaded lazily once the component has been mounted in the DOM.</p>\n<p>Lifestyle functions must be called while the component is initialising so that the callback is bound to the component instance - not (say) in a <code>setTimeout</code>.</p>\n<p>If the <code>onMount</code> callback returns a function, that function will be called when the component is destroyed.</p>\n<h2>onDestroy</h2>\n<p>To run code when your component is destroyed, use <code>onDestroy</code>.</p>\n<p>For example, we can add a <code>setInterval</code> function when our component initialises, and clean it up when it is no longer relevant. Doing so prevents memory leaks.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> {onDestroy} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'svelte'</span>;\n\t<span class=\"hljs-keyword\">let</span> counter = <span class=\"hljs-number\">0</span>\n\t<span class=\"hljs-keyword\">const</span> interval = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =></span> counter += <span class=\"hljs-number\">1</span>)\n\t<span class=\"hljs-title function_\">onDestroy</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">cleanInterval</span>(interval))\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></code></pre>\n<p>While it is important to call lifestyle functions during the component's initialisation, it does not matter <em>where</em> you call them from. So if we wanted, we could abstract the internal logic into a helper function in <code>utils.js</code> ...</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {onDestroy} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"svelte\"</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">onInterval</span>(<span class=\"hljs-params\">callback, milliseconds</span>) {\n\t<span class=\"hljs-keyword\">const</span> interval = <span class=\"hljs-built_in\">setInterval</span>(callback, milliseconds)\n\t<span class=\"hljs-title function_\">onDestroy</span>(<span class=\"hljs-function\">() =></span> {\n\t\t<span class=\"hljs-built_in\">clearInterval</span>(interval)\n\t})\n}</code></pre>\n<p>...and import it into our component:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> {onInterval} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./util.js\"</span>\n\t<span class=\"hljs-keyword\">let</span> counter = <span class=\"hljs-number\">0</span>\n\t<span class=\"hljs-title function_\">onInterval</span>(<span class=\"hljs-function\">() =></span> counter += <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1000</span>)\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span></code></pre>\n<h2>beforeUpdate and afterUpdate</h2>\n<p>The <code>beforeUpdate</code> function schedules work to happen immediately before the DOM is updated, <code>afterUpdate</code> is its counterpart, used for running code once the DOM is in sync with your data.</p>\n<p>Together, they are useful for doing things imperatively that are difficult to achieve in a purely state-driven way.</p>\n<h4>Example 1: Updating a DOM element</h4>\n<p>Suppose you have a Svelte component that renders a button element. You want to update the button's text whenever a prop value changes. You can use the <code>beforeUpdate</code> lifecycle method to get the current value of the prop before it updates, and the <code>afterUpdate</code> method to update the button text after it has updated.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> buttonText;\n<span class=\"hljs-keyword\">let</span> button;\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">beforeUpdate</span>(<span class=\"hljs-params\"></span>) {\n\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Button text before update: \"</span>, button.<span class=\"hljs-property\">textContent</span>)\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">afterUpdate</span>(<span class=\"hljs-params\"></span>){\n\tbutton.<span class=\"hljs-property\">textContent</span> = buttonText\n}\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">bind:this</span>=<span class=\"hljs-string\">{button}</span>></span>{buttonText}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></code></pre>\n<h4>Example 2: Animating a component</h4>\n<p>Suppose you have a Svelte component that displays a message, and you want to animate it whenever the message changes. You can use the <code>beforeUpdate</code> and <code>afterUpdate</code> methods to add a CSS class to the component before it updates, and remove it after it has updated.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> message;\n\t<span class=\"hljs-keyword\">let</span> container\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">beforeUpdate</span>(<span class=\"hljs-params\"></span>){\n\t\tcontainer.<span class=\"hljs-property\">classList</span>.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">\"animate\"</span>)\n\t}\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">afterUpdate</span>(<span class=\"hljs-params\"></span>){\n\t\tcontainer.<span class=\"hljs-property\">classList</span>.<span class=\"hljs-title function_\">remove</span>(<span class=\"hljs-string\">\"animate\"</span>)\n\t}\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"container\"</span> <span class=\"hljs-attr\">bind:this</span>=<span class=\"hljs-string\">{container}</span>></span>{message}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></code></pre>\n<h2>tick</h2>\n<p>The <code>tick</code>  function is unlike other lifecycle functions in that you can call it any time, not just when the component initialises. It returns a promise that resolves as soon as any pending state changes have been applied to the DOM (or immediately, if there are no pending state changes).</p>\n<p>When you update component state in Svelte, it does not update the DOM immediately. Instead, it waits until the nextt <code>microtask</code> to see if there are any other changes that need to be applied including in other components. Doing so avoids unnecessary work and allows the browser to batch things more efficiently.</p>\n<h4>Example 1: Waiting for a component to be fully rendered before calling a function</h4>\n<p>Suppose you have a Svelte component that renders a list of items. You want to call a function that manipulates the list items after they have been rendered. You can use <code>tick</code> to apply the pending state changes immediately.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> items = []\n\t<span class=\"hljs-keyword\">let</span> list\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">manipulateList</span>(<span class=\"hljs-params\"></span>) {\n\t\t<span class=\"hljs-title function_\">tick</span>().<span class=\"hljs-title function_\">then</span>( <span class=\"hljs-function\">() =></span> {\n\t\t\tlist.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">\".item\"</span>).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, index</span>) =></span> {\n\t\t\t\titem.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">`Item <span class=\"hljs-subst\">${index + <span class=\"hljs-number\">1</span>}</span>`</span>\n\t\t\t})\n\t\t} )\n\t}\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>=<span class=\"hljs-string\">{manipulateList}</span>></span>Manipulate List<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">bind:this</span>=<span class=\"hljs-string\">{list}</span>></span>\n\t{#each items as item}\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">li</span>></span> class=\"item\">{item}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">li</span>></span>\n\t{/each}\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ul</span>></span></code></pre>\n<h4>Example 2: Updating a component property after an animation</h4>\n<p>Suppose you have a Svelte component that contains an element that you want to animate. After the animation completes, you want to update a property of the component. You can use <code>tick</code> to apply the pending state changes before updating the property.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> isOpen = <span class=\"hljs-literal\">false</span>\n<span class=\"hljs-keyword\">let</span> box\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">toggleBox</span>(<span class=\"hljs-params\"></span>) {\n\tisOpen = !isOpen\n\tbox.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">height</span> = isOpen ? <span class=\"hljs-string\">\"200px\"</span> : <span class=\"hljs-string\">\"0\"</span>\n\t<span class=\"hljs-title function_\">tick</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">() =></span> {\n\t\tbox.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">background</span> = isOpen ? <span class=\"hljs-string\">\"green\"</span> : <span class=\"hljs-string\">\"red\"</span>;\n\t})\n}\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>=<span class=\"hljs-string\">{toggleBox}</span>></span>Toggle Box<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"box\"</span> <span class=\"hljs-attr\">bind:this</span>=<span class=\"hljs-string\">{box}</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">style</span>></span><span class=\"css\"> <span class=\"hljs-selector-class\">.box</span> { <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">0</span>; <span class=\"hljs-attribute\">background</span>: red; <span class=\"hljs-attribute\">transition</span>: height <span class=\"hljs-number\">0.3s</span>; } </span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">style</span>></span></code></pre>\n<p>``</p>\n"},{"tags":[{"name":"svelte","id":"svelte-753705"}],"title":"Lifecycle of a component in svelte","date":null,"description":"","slug":"lifecycle-of-a-component-in-svelte","id":"lifecycle-of-a-component-in-svelte-559478","content":"<p>Svelte is a popular JavaScript framework that provides a powerful toolset for building dynamic web applications. One of the key features of Svelte is its component-based architecture, which allows developers to create reusable and modular UI elements. In this article, we will explore the lifecycle of a Svelte component and the various methods that are available to manage the component's state and behavior.</p>\n<h2>Component Lifecycle Overview</h2>\n<p>A Svelte component goes through several stages during its lifecycle, including creation, initialization, updates, and destruction. Each stage provides an opportunity for the developer to perform specific actions or update the component's state. Here is a high-level overview of the component lifecycle in Svelte:</p>\n<ol>\n<li><strong>Creation</strong>: The component is created and initialized with the initial state and properties.</li>\n<li><strong>Intialization</strong>: The <code>onMount</code> lifecycle method is called, allowing the developer to perform initial setup tasks, such as fetching data from an API or setting up event listeners.</li>\n<li><strong>Updates</strong>: The component's state or properties are updated, triggering the <code>beforeUpdate</code> and <code>afterUpdate</code> lifecycle methods.</li>\n<li><strong>Destruction</strong>: The component is removed from the DOM and the <code>onDestroy</code> lifecycle method is called, allowing the developer to perform cleanup tasks.</li>\n</ol>\n<h2>Creation</h2>\n<p>The creation stage is the first step in a component's lifecycle. During this stage, the component is created and initialized with the intial state and properties. In Svelte, the <code>export</code> statement is used to define the properties that a component expects to receive. For example:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">\"World\"</span>\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>Hello {name}! <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span></code></pre>\n<p>In this example, the <code>name</code> property is defined using the <code>export</code> statement and is set to a default value of \"World\". When this component is used in a parent component, the <code>name</code> property can be overridden to display a custom greeting.</p>\n<h2>Intialization</h2>\n<p>The initialization stage is the next step in a component's lifecycle. During this stage, the component is mounted to the DOM and the <code>onMount</code> lifecycle method is called.  The <code>onMount</code> method is used to perform initial setup tasks, such as fetching data from the API or setting up event listeners.</p>\n<h2>Updates</h2>\n<p>The update stage is triggered whenever a component's state or properties are updated. During this stage, the <code>beforeUpdate</code> and <code>afterUpdate</code> lifecycle methods are called, allowing the developer to perform tasks before and after the update. Here is an example:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleClick</span>(<span class=\"hljs-params\"></span>){\n\t\tcount++;\n\t}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">beforeUpdate</span>(<span class=\"hljs-params\"></span>){\n\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Before Update\"</span>, count)\n}\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">afterUpdate</span>(<span class=\"hljs-params\"></span>){\n\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"After Update\"</span>, count)\n}\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>=<span class=\"hljs-string\">{handleClick}</span>></span> Increment <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></code></pre>\n<h2>Destruction</h2>\n<p>The destruction stage is triggered when a component is removed from the DOM. During this stage, the <code>onDestroy</code> lifecycle method is called, allowing the developer to perform cleanup tasks, such as removing event listeners or cleaning up resources. Here is an example:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> {onDestroy, onMount} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">`svelte`</span>;\n\t\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleClick</span>(<span class=\"hljs-params\"></span>){\n\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Button Clicked   \"</span>)\n\t}\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-params\"></span>){\n\t\t<span class=\"hljs-keyword\">const</span> button = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">\"button\"</span>)\n\t\tbutton.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">\"click\"</span>, handleClick)\n\t}\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">removeClickListener</span>(<span class=\"hljs-params\"></span>){\n\t\t<span class=\"hljs-keyword\">const</span> button = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">\"button\"</span>)  \n\t\tbutton.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">\"click\"</span>, handleClick)\n\t}\n\n\t<span class=\"hljs-title function_\">onMount</span>(<span class=\"hljs-function\">() =></span> {\n\t\t<span class=\"hljs-title function_\">addEventListener</span>()\n\t})\n\t<span class=\"hljs-title function_\">onDestroy</span>(<span class=\"hljs-function\">() =></span> {\n\t\t<span class=\"hljs-title function_\">removeClickListener</span>()\n\t})   \n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>></span> Click Me <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></code></pre>\n"},{"tags":[{"name":"svelte","id":"svelte-225379"}],"title":"Reactivity in Svelte","date":null,"description":"","slug":"reactivity-in-svelte","id":"reactivity-in-svelte-357602","content":"<h2>Assignment</h2>\n<p>At the heart of Svelte is a powerful system of <em>reactivity</em> for keeping the DOM in sync with your application state - for example, in response to an event.</p>\n<p>For example:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">incrementCount</span>(<span class=\"hljs-params\"></span>) {\n\t\tcount += <span class=\"hljs-number\">1</span>\n\t}\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>=<span class=\"hljs-string\">{incrementCount}</span>></span>\n\tClicked {count} {count === 1 ? 'time' : 'times'}\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></code></pre>\n<p>Svelte 'instruments' this assignment with some code that tells it the DOM will need to be updated.</p>\n<h2>Declarations</h2>\n<p>Svelte's reactivity not only keeps the DOM in sync with your application's variables, it cam also keep variables in sync with each other using reactive declarations. They look like this:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>\n<span class=\"hljs-attr\">$</span>: doubled = count * <span class=\"hljs-number\">2</span></code></pre>\n<p>Svelte interepts it to mean 're-run' this code whenever any of the referenced values change.</p>\n<p>Let's use <code>doubled</code> in our markup:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{count} doubled is {doubled} <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span></code></pre>\n<p>Ofcourse, you could just write <code>{count * 2}</code> in the markup instead - you do not have to use reactive values. Reactive values become particularly valuable when you need to reference them multiple times, or you have values that depend on <code>other</code> reactive values.</p>\n<p>Svelte does not re-render the entire component whenever the value of any variable changes. Instead, <strong>Svelte uses a technique called \"reactive declarations\" to track which parts of the component's template depend on which variables, and only updates those parts of the DOM when the corresponding values change</strong>.</p>\n<p>When a Svelte component is compiled, it generates optimized code that includes the reactive declarations for all the variables in the component. These reactive declarations create 'subscriptions' that track which parts of the component's template depend on each variable.</p>\n<p>When a variable changes, Svelte uses these subscriptions to determine which part of the template need to be updated. It then generates optimized DOM updates that only updates those parts of the template, instead of re-rendering the entire component.</p>\n<h2>Statements</h2>\n<p>We are not limited to declaring reactive values - we can also run aribitrary statements reactively. For example, we can log the value of <code>count</code> whenever it changes:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">$</span>: <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"the count is \"</span> + count)</code></pre>\n<p>You can easily group statements together with a block:</p>\n<pre><code class=\"hljs language-js\">$ : {\n\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"the count is \"</span> + count)\n\t<span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">\"I SAID THE COUNT IS \"</span> + count)\n}</code></pre>\n<p>You can even put the <code>$:</code> in front of things like <code>if</code> blocks:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">$</span>: <span class=\"hljs-keyword\">if</span> (count >= <span class=\"hljs-number\">10</span>){\n\t<span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">\"count is dangerously high\"</span>)\n\tcount = <span class=\"hljs-number\">9</span>\n}</code></pre>\n<h2>Updating arrays and objects</h2>\n<p><strong>Svelte's reactivity is triggered by assignments.</strong> Methods that mutate arrays or objects will not trigger updates by themselves.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">let</span> numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n\n\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">addNumber</span>(<span class=\"hljs-params\"></span>) {\n\t\tnumbers.<span class=\"hljs-title function_\">push</span>(numbers.<span class=\"hljs-property\">length</span> + <span class=\"hljs-number\">1</span>);\n\t}\n\n\t<span class=\"hljs-attr\">$</span>: sum = numbers.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">t, n</span>) =></span> t + n, <span class=\"hljs-number\">0</span>);\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>{numbers.join(' + ')} = {sum}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>=<span class=\"hljs-string\">{addNumber}</span>></span>\n\tAdd a number\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></code></pre>\n<p>In this example, clicking the \"Add a number\" button calls the <code>addNumber</code> function, which appends a number to the array but does not trigger the recalculation of <code>sum</code>.</p>\n<p>One way to fix this is to assign <code>numbers</code> to itself to tell the compiler it has changed:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">addNumber</span>(<span class=\"hljs-params\"></span>){\n\tnumbers.<span class=\"hljs-title function_\">push</span>(numbers.<span class=\"hljs-property\">length</span> + <span class=\"hljs-number\">1</span>)\n\tnumbers = numbers\n}</code></pre>\n<p>You could also write this more concisely using the ES6 spread syntax:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">addNumber</span>(<span class=\"hljs-params\"></span>){\n\tnumbers = [...numbers, numbers.<span class=\"hljs-property\">length</span> + <span class=\"hljs-number\">1</span>]\n}</code></pre>\n<p>The same rule applies to array methods such as <code>pop</code>, <code>shift</code>, and <code>splice</code> and to object methods such as <code>Map.set</code>, <code>Set.add</code>, etc.</p>\n<p>Assignments to <code>properties</code> of arrays and objects - e.g. <code>obj.foo += 1</code> or <code>array[i] = x</code> - work the same way as assignments to the value themselves.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">addNumber</span>(<span class=\"hljs-params\"></span>) {\n\tnumbers[numbers.<span class=\"hljs-property\">length</span>] = numbers.<span class=\"hljs-property\">length</span> + <span class=\"hljs-number\">1</span>\n}</code></pre>\n<p>However, indirect assignments to references such as this...</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> foo = obj.<span class=\"hljs-property\">foo</span>\nfoo.<span class=\"hljs-property\">bar</span> = <span class=\"hljs-string\">\"baz\"</span></code></pre>\n<p>or</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">quox</span>(<span class=\"hljs-params\">thing</span>){\n\tthing.<span class=\"hljs-property\">foo</span>.<span class=\"hljs-property\">bar</span> = <span class=\"hljs-string\">\"baz\"</span>\n}\n<span class=\"hljs-title function_\">quox</span>(obj)</code></pre>\n<p>...won't trigger reactivity on <code>obj.foo.bar</code>, unless you follow it up with <code>obj=obj</code></p>\n<p>A simple rule of thumb: the updated variable must directly appear on the left hand side of the assignment.</p>\n"},{"tags":[{"name":"sveltekit","id":"sveltekit-307992"}],"title":"Basic Concepts in SvelteKit","date":null,"description":"","slug":"basic-concepts-in-sveltekit","id":"basic-concepts-in-sveltekit-748055","content":"<h2>What is SvelteKit?</h2>\n<p>It is a framework for building high-performance apps. Whereas Svelte is <code>component framework</code>, SvelteKit is an <code>app framework</code> that solves the tricky problems of building something production-ready:</p>\n<ul>\n<li>Routing</li>\n<li>Server-side rendering</li>\n<li>Data fetching</li>\n<li>Service workers</li>\n<li>TypeScript integration</li>\n<li>Prerendering</li>\n<li>Single-page apps</li>\n<li>Library packaging</li>\n<li>Optimised production builds</li>\n<li>Deploying to different hosting providers</li>\n<li>...and so on</li>\n</ul>\n<p>SvelteKit apps are server-rendered by default( like traditional 'multi-page apps' or MPAs) for excellent first load performance and SEO characterstics, but then can then transition to client-side navigation (like modern 'single-page apps' or SPAs) to avoid jankily reloading everything (including things like third-party analytics code) when the user navigates.</p>\n<h2>Project structure</h2>\n<pre><code>my-sveltekit-project/\n├── src/\n│   ├── routes/\n│   │   ├── index.svelte\n│   │   └── about.svelte\n│   ├── lib/\n│   │   ├── api.js\n│   │   └── utils.js\n│   ├── components/\n│   │   ├── Button.svelte\n│   │   └── Card.svelte\n│   ├── app.html\n│   └── app.js\n├── static/\n│   ├── img/\n│   ├── css/\n│   └── js/\n├── package.json\n├── README.md\n├── .gitignore\n└── node_modules/\n</code></pre>\n<p>Let's break down the structure and its contents:</p>\n<ul>\n<li>\n<p><code>src/</code>: This directory contains all the source code of your SvelteKit project.</p>\n<ul>\n<li>\n<p><code>routes/</code>: This directory contains all the routes of your application. Each <code>.svelte</code> file in this directory will automatically become a page in your app.</p>\n</li>\n<li>\n<p><code>lib/</code>: This directory contains any reusable utility functions, constants, or API integrations.</p>\n</li>\n<li>\n<p><code>components/</code>: This directory contains all the reusable components that are used in your pages.</p>\n</li>\n<li>\n<p><code>app.html</code>: This file contains the HTML structure of your app, and any meta tags, scripts, or links you want to include in the head of your page.</p>\n</li>\n<li>\n<p><code>app.js</code>: This file contains the initialization code for your SvelteKit app.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>static/</code>: This directory contains all the static assets like images, CSS, and JavaScript files that need to be served as-is.</p>\n</li>\n<li>\n<p><code>package.json</code>: This file contains all the dependencies, scripts, and metadata of your project.</p>\n</li>\n<li>\n<p><code>README.md</code>: This file contains the documentation of your project.</p>\n</li>\n<li>\n<p><code>.gitignore</code>: This file specifies the files and directories that should be ignored by Git.</p>\n</li>\n<li>\n<p><code>node_modules/</code>: This directory contains all the installed dependencies of your project.</p>\n</li>\n</ul>\n<h2>Server and client</h2>\n<p>A SvelteKit app can be thought of as two distinct entities working in tandem - the <em>server</em> and the <em>client</em>.</p>\n<p>SvelteKit makes  the two communicate with each other seamlessly. On the initial page load, the server renders the HTML, meaning the content is visible as quickly as possible. The client then takes over in a process called <code>hydration</code>, so that subsequent naviagtions happen without full page reloads. It will request additonal code and data from the server as needed.</p>\n"},{"tags":[{"name":"sveltekit","id":"sveltekit-353828"}],"title":"Getting started with SvelteKit","date":null,"description":"","slug":"getting-started-with-sveltekit","id":"getting-started-with-sveltekit-283785","content":"<p>SvelteKit is a tool for building web applications using the Svelte framework.</p>\n<h2>Install Nodejs</h2>\n<p>To use SvelteKit, you need to have Node.js installed on your machine.</p>\n<h2>Create a SvelteKit project</h2>\n<p>To create a new SvelteKit project, you can use the <code>create-svelte</code> command-line tool. Run the following command in your terminal:</p>\n<pre><code>npx create-svelte@latest my-app\n</code></pre>\n<p>This will create a new SvelteKit project in a directory called <code>my-app</code>.</p>\n<h2>Choose a project template</h2>\n<p>When creating a new SvelteKit project, you can choose from several project templates, including a \"Skeleton\" project that provides a basic starting point for your application.</p>\n<h2>Start the Development Server</h2>\n<p>Once you have created your SvelteKit project, you can start the development server by running the folloowing command:</p>\n<pre><code>cd my-app\nnpm run dev\n</code></pre>\n<p>This will start the development server and open your app in a web browser at <code>http://localhost:3000</code></p>\n<h2>Build and deploy your app</h2>\n<p>When you are ready to develop your app, you can build using the following command:</p>\n<pre><code>npm run build\n</code></pre>\n<p>This will create a production-ready build of your app in a <code>build</code> directory. You can then build to a web server or hosting service of your choice.</p>\n"},{"tags":[{"name":"sveltekit","id":"sveltekit-203218"}],"title":"How to configure tailwind with sveltekit","date":null,"description":"","slug":"how-to-configure-tailwind-with-sveltekit","id":"how-to-configure-tailwind-with-sveltekit-379193","content":"<h3>Create your SvelteKit project</h3>\n<pre><code>npm init svelte@latest my-app\ncd my-app\n\n</code></pre>\n<h3>Install Tailwind CSS</h3>\n<pre><code>npm install -D tailwindcss postcss autoprefixer\n</code></pre>\n<p>Then, run the following command to generate both <code>tailwind.config.cjs</code> and <code>postcss.config.cjs</code>:</p>\n<pre><code>npx tailwindcss init -p\n</code></pre>\n<p>Next, change the created <code>tailwind.config.js</code> to a CommonJS module by renaming it to <code>tailwind.config.cjs</code>. You just need to change the extension to <code>cjs</code>.</p>\n<p>Next, change the created <code>tailwind.config.js</code> to a CommonJS module by renaming it to <code>tailwind.config.cjs</code>. You just need to change the extension to <code>cjs</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// tailwind.config.cjs</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">purge</span>: [<span class=\"hljs-string\">'src/app.html'</span>, <span class=\"hljs-string\">'src/**/*.svelte'</span>],\n    ...\n}</code></pre>\n<p>Create a <code>styles.css</code> file in the <code>src</code> folder with the following content:</p>\n<pre><code class=\"hljs language-css\">// ./<span class=\"hljs-attribute\">src</span>/style<span class=\"hljs-selector-class\">.css</span>\n<span class=\"hljs-keyword\">@tailwind</span> base;\n<span class=\"hljs-keyword\">@tailwind</span> components;\n<span class=\"hljs-keyword\">@tailwind</span> utilities;</code></pre>\n<p>Now, create a layout component to import the styles from:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// ./src/routes/+layout.svelte </span>\n&#x3C;script> \n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'../style.css'</span>; \n&#x3C;/script></code></pre>\n<h3>Add Tailwind includes to your Svelte App</h3>\n<p>In your <code>svelte.config.cjs</code> file, add postcss as a preprocessor:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// svelte.config.cjs</span>\n<span class=\"hljs-keyword\">const</span> sveltePreprocess = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'svelte-preprocess'</span>);\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">preprocess</span>: <span class=\"hljs-title function_\">sveltePreprocess</span>({\n        <span class=\"hljs-attr\">postcss</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">defaults</span>: {\n            <span class=\"hljs-attr\">style</span>: <span class=\"hljs-string\">'postcss'</span>,\n        },\n    }),\n};\n</code></pre>\n<p>And create a <code>postcss.config.cjs</code> file in the root of the project:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// postcss.config.cjs</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n    <span class=\"hljs-attr\">plugins</span>: {\n        <span class=\"hljs-string\">'tailwindcss'</span>: {},\n        <span class=\"hljs-attr\">autoprefixer</span>: {},\n    },\n};\n</code></pre>\n<p>In your Svelte app, add the following code to your <code>index.svelte</code> file or any other Svelte component:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">global</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"postcss\"</span>></span><span class=\"css\">\n    <span class=\"hljs-keyword\">@tailwind</span> base;\n    <span class=\"hljs-keyword\">@tailwind</span> components;\n    <span class=\"hljs-keyword\">@tailwind</span> utilities;\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">style</span>></span>\n</code></pre>\n"},{"tags":[{"name":"sveltekit","id":"sveltekit-983937"}],"title":"Loading Data in SvelteKit","date":null,"description":"","slug":"loading-data-in-sveltekit","id":"loading-data-in-sveltekit-191102","content":"<h2>Page Data</h2>\n<p>At its core, SvelteKit's job boils down to three things:</p>\n<ol>\n<li><strong>Routing</strong> -  figure out which route matches an incoming request</li>\n<li><strong>Loading</strong> - get the data needed by the route</li>\n<li><strong>Rendering</strong> -  generate some HTML (on the server) or update the DOM (in the browser)</li>\n</ol>\n<p>Every page of your app can declare a <code>load</code> function in a <code>+page.server.js</code> file alongside the <code>+page.svelte</code> file. As the file name suggests, this module only ever runs on the server, including for client-side navigations.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/routes/blog/+page.server.js</span>\n<span class=\"hljs-keyword\">import</span> { posts } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./data.js'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">load</span>(<span class=\"hljs-params\"></span>) {\n\t<span class=\"hljs-keyword\">return</span> {\n\t\t<span class=\"hljs-attr\">summaries</span>: posts.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">post</span>) =></span> ({\n\t\t\t<span class=\"hljs-attr\">slug</span>: post.<span class=\"hljs-property\">slug</span>,\n\t\t\t<span class=\"hljs-attr\">title</span>: post.<span class=\"hljs-property\">title</span>\n\t\t}))\n\t};\n}</code></pre>\n<blockquote>\n<p>For the sake of the tutorial, we're importing data from <code>src/routes/blog/data.js</code>. In a real app, you'd be more likely to load the data from a database or a CMS, but for now we'll do it like this.</p>\n</blockquote>\n<p>We can access this data in <code>src/routes/blog/+page.svelte</code> via the <code>data</code> prop:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> data;\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>blog<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ul</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">li</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/blog/one\"</span>></span>one<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">li</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">li</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/blog/two\"</span>></span>two<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">li</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">li</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/blog/three\"</span>></span>three<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">li</span>></span>\n\t{#each data.summaries as { slug, title }}\n\t\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">li</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/blog/{slug}\"</span>></span>{title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">li</span>></span>\n\t{/each}\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ul</span>></span></code></pre>\n<p>Now, let's do the same for the post page:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/routes/blog/[slug]/+page.server.js</span>\n<span class=\"hljs-keyword\">import</span> { posts } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../data.js'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">load</span>(<span class=\"hljs-params\">{ params }</span>) {\n\t<span class=\"hljs-keyword\">const</span> post = posts.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">post</span>) =></span> post.<span class=\"hljs-property\">slug</span> === params.<span class=\"hljs-property\">slug</span>);\n\t<span class=\"hljs-keyword\">return</span> {\n\t\tpost\n\t};\n}</code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&#x3C;!--src/routes/blog/[slug]/+page.svelte--></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> data;\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>blog post<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>{data.post.title}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>{@html data.post.content}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></code></pre>\n<p>There's one last detail we need to take care of — the user might visit an invalid pathname like <code>/blog/nope</code>, in which case we'd like to respond with a 404 page:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// src/routes/blog/[slug]/+page.server.js</span>\n<span class=\"hljs-keyword\">import</span> { error } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@sveltejs/kit'</span>;\n<span class=\"hljs-keyword\">import</span> { posts } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../data.js'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">load</span>(<span class=\"hljs-params\">{ params }</span>) {\n\t<span class=\"hljs-keyword\">const</span> post = posts.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">post</span>) =></span> post.<span class=\"hljs-property\">slug</span> === params.<span class=\"hljs-property\">slug</span>);\n\n\t<span class=\"hljs-keyword\">if</span> (!post) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title function_\">error</span>(<span class=\"hljs-number\">404</span>);\n\n\t<span class=\"hljs-keyword\">return</span> {\n\t\tpost\n\t};\n}</code></pre>\n"},{"tags":[{"name":"sveltekit","id":"sveltekit-219949"}],"title":"Routing in SvelteKit","date":null,"description":"","slug":"routing-in-sveltekit","id":"routing-in-sveltekit-737555","content":"<h2>Pages</h2>\n<p>SvelteKit uses filesystem-based routing, which means that the <em>routes</em> of your app - in other words, what the app should do when a user navigates to a particular URL - are defined by the directories in your codebase.</p>\n<p>The routes are located within <code>src/routes</code>. Every directory within which contains a <code>+page.svelte</code> file creates a route in your app.</p>\n<p><code>src/routes/+page.svelte</code> maps to <code>/</code></p>\n<p><code>src/routes/about/+page.svelte</code> maps to <code>/about</code></p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">nav</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/\"</span>></span>home<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/about\"</span>></span>about<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">nav</span>></span></code></pre>\n<blockquote>\n<p>Unlike traditional multi-page apps, navigating to <code>/about</code> and back updates the contents of the current page, like a single-page app. This gives us the best of both worlds — fast server-rendered startup, then instant navigation. (This behaviour can be <a href=\"https://kit.svelte.dev/docs/page-options\">configured</a>.)</p>\n</blockquote>\n<h2>Layouts</h2>\n<p>Different routes of your app will often share common UI. Instead of repeating it in each <code>+page.svelte</code> component, we can use a <code>+layout.svelte</code> component that applies to all routes in the same directory.</p>\n<p>We have two routes, <code>src/routes/+page.svelte</code> and <code>src/routes/about/+page.svelte</code>, that contain the same navigation UI.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&#x3C;!--src/routes/+page.svelte--></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">nav</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/\"</span>></span>home<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/about\"</span>></span>about<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">nav</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>home<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>this is the home page.<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span></code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&#x3C;!--src/routes/about/+page.svelte--></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">nav</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/\"</span>></span>home<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/about\"</span>></span>about<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">nav</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>about<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>this is the about page.<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span></code></pre>\n<p>Let's create a new file <code>src/routes/+layout.svelte</code> and move the duplicated content from the <code>+page.svelte</code> files into the new <code>+layout.svelte</code> file. The <code>&#x3C;slot /></code> element is where the page content will be rendered:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&#x3C;!--src/routes/+layout.svelte--></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">nav</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/\"</span>></span>home<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"/about\"</span>></span>about<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">nav</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">slot</span> /></span></code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&#x3C;!--src/routes/+page.svelte--></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>home<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span> \n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>this is the home page.<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span></code></pre>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&#x3C;!--src/routes/about/+page.svelte--></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>about<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>this is the about page.<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span></code></pre>\n<p>A <code>+layout.svelte</code> file applies to every child route, including the sibling <code>+page.svelte</code> (if it exists). You can nest layouts to arbitrary depth.</p>\n<h2>Route parameters</h2>\n<p>To create routes with dynamic parameetrs, use square brackets around a valid variable name. For example, a file like <code>src/routes/blog/[slug]/+page.svelte</code> will create a route that matches <code>/blog/one</code>, <code>/blog/two</code>, <code>/blog/three</code> and so on.</p>\n<blockquote>\n<p>Multiple route parameters can appear <em>within</em> one URL segment, as long as they are separated by at least one static character: <code>foo/[bar]x[baz]</code> is a valid route where <code>[bar]</code> and <code>[baz]</code> are dynamic parameters.</p>\n</blockquote>\n"},{"title":"Tutorial on getStaticPaths in Nextjs","date":"2023-06-01 08:02","tags":[{"name":"nextjs","id":"nextjs-186505"}],"description":"","slug":"tutorial-on-getstaticpaths-in-nextjs","id":"tutorial-on-getstaticpaths-in-nextjs-20827","content":"<h2>Introduction</h2>\n<p><code>getStaticPaths</code> is a function used in Next.js to pre-generate static pages for dynamic routes. It is used in combination with <code>getStaticProps</code> to statically pre-render pages that use dynamic routes. The function should be exported from the page that uses dynamic routes.</p>\n<h2>When to use getStaticPaths</h2>\n<p>You should use <code>getStaticPaths</code> if:</p>\n<ul>\n<li>You are statically pre-rendering pages that use dynamic routes</li>\n<li>The page must be pre-rendered (for SEO) and be very fast.</li>\n<li>The data can be stored directly and is not client-specific.</li>\n</ul>\n<h2>getStaticPaths function</h2>\n<p>The <code>getStaticPaths</code> function in Next.js is used to pre-generate static pages for dynamic routes. It is during the build process in production, and it will not be called during runtime.</p>\n<p>The function returns an object with two properties:</p>\n<ul>\n<li><code>paths</code> : an array of the dynamic parameters of the pre-generated static pages.</li>\n<li><code>fallback</code> : a variable that controls the action when the user is trying to access a page whose dynamic parameter is not listed in the <code>paths</code> array. It has three values:\n<ul>\n<li><code>false</code>: The default value of the <code>fallback</code> property. If the request of the user is not listed in the <code>paths</code> array, Next.js will return a 404 page as the result.</li>\n<li><code>true</code>: Tells Next.js to generate the static version for the user's request on the fly.</li>\n<li><code>blocking</code> : This is similar to <code>fallback: true</code> in that it does not return a 404 page for paths that have not yet been generated. However, unlike <code>fallback: true</code>, there is no fallback page displayed to users. Instead, Next.js blocks or waits for the page to be generated before displaying anything to the user. Once the page has been generated, it will be cached, and all future visits will receive the generated page.</li>\n</ul>\n</li>\n</ul>\n<p>When using the <code>fallback: 'blocking'</code>, you do not need to check for <code>router.isFallback</code> in your component, as Next.js will wait for the page to be generated before sending a response to the user's browser.</p>\n<h2>Example</h2>\n<p>Here is an example of how to use <code>getStaticPaths</code> with a dynamic route <code>/user/[userId].js</code></p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getStaticPaths</span>(<span class=\"hljs-params\"></span>) {\n\t<span class=\"hljs-keyword\">const</span> users = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-comment\">// fetch users data</span>\n\n\t<span class=\"hljs-comment\">// Generate the paths</span>\n\t<span class=\"hljs-keyword\">const</span> paths = users.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">user</span> =></span> ({\n\t\tparams : { userId : user.<span class=\"hljs-property\">id</span> }\n\t}))\n\n\t<span class=\"hljs-keyword\">return</span> {\n\t\tpaths, \n\t\tfallback : <span class=\"hljs-literal\">true</span>\n\t}\n\n}</code></pre>\n<p>Here is an example of how to use <code>getStaticPaths</code> with <code>fallback: 'blocking'</code></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getStaticPaths</span>(<span class=\"hljs-params\"></span>) {\n\n<span class=\"hljs-keyword\">return</span> {\n\tpaths : [],\n\tfallback : <span class=\"hljs-string\">\"blocking\"</span>\n}\n}</code></pre>\n<h2>Handling Fallback</h2>\n<p>When using <code>fallback</code> set to <code>true</code>, you need to render a fallback component in your page component to avoid errors when trying to access data from props. You can render a fallback like this:</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-keyword\">import</span> {useRouter} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/router'</span>\n<span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">useRouter</span>()\n<span class=\"hljs-keyword\">if</span> (router.<span class=\"hljs-property\">isFallback</span>) {\n\t<span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>loading...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n}</code></pre>\n<h2>Conclusion</h2>\n<p><code>getStaticPaths</code> is a powerful function in Nex.js that allows you to pre-generate static pages for dynamic routes. It is used in combination with <code>getStaticProps</code> and is called during the build process. By properly configuring the <code>paths</code> and <code>fallback</code> properties, you can optimize your application's performance and SEO.</p>\n"},{"title":"Tutorial on sorting an array of objects in JavaScript","date":"2023-06-01 04:11","tags":[{"name":"javascript","id":"javascript-771173"}],"description":"","slug":"tutorial-on-sorting-an-array-of-objects-in-javascript","id":"tutorial-on-sorting-an-array-of-objects-in-javascript-225822","content":"<h2>Introduction</h2>\n<p>In this tutorial, we will discuss how to sort an array of objects in JavaScript using the <code>Array.sort()</code> method and providing a comparison function that determines the order of the objects.</p>\n<p>First, let's create an array of objects:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> employees = [\n  { <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'John'</span>, <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'Doe'</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">27</span>, <span class=\"hljs-attr\">joinedDate</span>: <span class=\"hljs-string\">'December 15, 2017'</span> },\n  { <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Jane'</span>, <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'Doe'</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">32</span>, <span class=\"hljs-attr\">joinedDate</span>: <span class=\"hljs-string\">'January 1, 2018'</span> },\n  { <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Mike'</span>, <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'Johnson'</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">27</span>, <span class=\"hljs-attr\">joinedDate</span>: <span class=\"hljs-string\">'February 1, 2018'</span> },\n];\n</code></pre>\n<p>Now, let's sort this array by the <code>age</code> property in ascending order:</p>\n<pre><code class=\"hljs language-js\">employees.<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> a.<span class=\"hljs-property\">age</span> - b.<span class=\"hljs-property\">age</span>)</code></pre>\n<p>You can also sort the array in descending order by changing the order of subtraction:</p>\n<pre><code class=\"hljs language-js\">exmployees.<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a , b</span>) =></span> b.<span class=\"hljs-property\">age</span> - a.<span class=\"hljs-property\">age</span>)</code></pre>\n<p>If you want to sort the array by a different property, such as <code>lastName</code>, you can modify the comparison function accordingly:</p>\n<pre><code class=\"hljs language-js\">employees.<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a , b</span>) =></span> {\n\t<span class=\"hljs-keyword\">const</span> lA = a.<span class=\"hljs-property\">lastName</span>.<span class=\"hljs-title function_\">toUpperCase</span>()\n\t<span class=\"hljs-keyword\">const</span> lB = b.<span class=\"hljs-property\">lastName</span>.<span class=\"hljs-title function_\">toUpperCase</span>()\n\t<span class=\"hljs-keyword\">if</span> (lA &#x3C; lB) <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>\n\t<span class=\"hljs-keyword\">if</span> (lA > lB) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n})</code></pre>\n<h2>How does it work?</h2>\n<p>The <code>Array.prototype.sort()</code> method sorts the elements of an array in place and returns aa reference to the same array, now sorted.</p>\n<p>When the <code>sort()</code> method compares two values, it sends the values to the compare function, and sorts the values according to the returned (negative, zero, positive) value. If the result is negative, <code>a</code> is sorted before <code>b</code>. If the result is positive, <code>b</code> is sorted before <code>a</code>. If the result is zero, no changes are done with the sort order of the two values.</p>\n<p>The <code>sort()</code> method accepts a compare function as an argument, which you can define to customize the sorting logic based on your requirements. The compare function should take two arguments, usually denoted as <code>a</code> and <code>b</code>, and return a positive, negative, or zero value depending on the desired order.</p>\n<h2>Conclusion</h2>\n<p>In conclusion, the <code>sort</code> method works by converting the array elements into strings and comparing their sequences of UTF-8 code unit values.</p>\n"},{"title":"Tutorial on the findIndex method of an Array","tags":[{"name":"javascript","id":"javascript-670849"}],"date":"2023-06-01 06:43","description":"","slug":"tutorial-on-the-findindex-method-of-an-array","id":"tutorial-on-the-findindex-method-of-an-array-359204","content":"<h2>Introduction</h2>\n<p>The <code>findIndex()</code> method in JavaScript is used to find the index of the first element in an array that satisfies a given condition. It returns the index of the first matching element, or -1 if no match is found. This method is particularly useful when working with complex data structures or when you need to locate a specific element based on certain criteria.</p>\n<h2>Syntax and Usage</h2>\n<p>The syntax for the <code>findIndex()</code> method is as follows:</p>\n<pre><code class=\"hljs language-js\">arr.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-title function_\">callback</span>(element, index, array), thisArg)</code></pre>\n<ul>\n<li><code>callback</code>: A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.</li>\n<li><code>thisArg</code>: Optional object to use as <code>this</code> when executing the callback.</li>\n<li><code>array</code> : Optional array in which the <code>findIndex</code> method is called.</li>\n</ul>\n<h2>Examples</h2>\n<p>Here are some examples of using the <code>findIndex()</code> method:</p>\n<p><strong>Example 1: Basic usage</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> lang = [<span class=\"hljs-string\">\"Java\"</span>, <span class=\"hljs-string\">\"JavaScript\"</span>]\nlang.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =></span> val === <span class=\"hljs-string\">'JavaScript'</span>) <span class=\"hljs-comment\">// 1</span>\nlang.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> val === <span class=\"hljs-string\">'Python'</span>) <span class=\"hljs-comment\">// -1</span></code></pre>\n<p><strong>Example 2: Using <code>findIndex</code> with a more complex condition</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> ranks = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">7</span>]\n<span class=\"hljs-keyword\">let</span> index = ranks.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">rank, index</span>) =></span> rank === <span class=\"hljs-number\">7</span> &#x26;&#x26; index > <span class=\"hljs-number\">2</span>)\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index) <span class=\"hljs-comment\">// 5</span></code></pre>\n<p><strong>Example 3: Using <code>findIndex</code> with an array of objects</strong></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> products = [\n{ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Phone'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">999</span> },\n{ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Computer'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">1999</span> },\n{ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Tablet'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">995</span> },\n]\n\n<span class=\"hljs-keyword\">const</span> index = products.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">product</span> =></span> product.<span class=\"hljs-property\">price</span> > <span class=\"hljs-number\">1000</span> )\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(index) <span class=\"hljs-comment\">// 1</span></code></pre>\n<h2>Trade-offs and Nuances</h2>\n<ul>\n<li>The <code>findIndex()</code> method is useful when you want to find the index of the first element that satisfies a given condition. However, if you need to find the indices of all elements that match the criteria, you should use the <code>reduce()</code> method instead of <code>findIndex()</code></li>\n<li>The <code>findIndex()</code> method is not supported in older browsers, such as Internet Explorer. If you need to support older browsers, you can use a polyfill or an alternative method like <code>Array.prototype.indexOf()</code></li>\n<li>The <code>findIndex()</code> method can be called on non-array objects, as long as they have a <code>length</code> property. However, the method may not work as expected, and you may need to use other methods like <code>Array.prototype.findIndex.call()</code></li>\n</ul>\n"},{"title":"Using Middleware in Next.js","date":"2023-06-01 12:06","tags":[{"name":"nextjs","id":"nextjs-305984"}],"description":"","slug":"using-middleware-in-nextjs","id":"using-middleware-in-nextjs-127881","content":"<h2>Introduction</h2>\n<p>Middleware allows you to run code before a request is completed. Then, based on the incoming request, you can either modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.</p>\n<p>Middleware runs before cached content and routes are matched.</p>\n<h2>Convention</h2>\n<p>Using the file <code>middleware.js</code> in the root of your project to define Middleware.</p>\n<h2>Example</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {<span class=\"hljs-title class_\">NextResponse</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/server\"</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">middleware</span>(<span class=\"hljs-params\">req, res</span>) {\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(<span class=\"hljs-string\">\"/home\"</span>, request.<span class=\"hljs-property\">url</span> ))\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> config = {\n\tmatcher : <span class=\"hljs-string\">\"/about/:path\"</span>\n}</code></pre>\n<h2>Matching Paths</h2>\n<p>Middleware will be invoked for <strong>every route in your project</strong>. The following is the execution order:</p>\n<ol>\n<li><code>headers</code> from <code>next.config.js</code></li>\n<li><code>redirects</code> from <code>next.config.js</code></li>\n<li>Middleware (<code>rewrites</code>, <code>redirects</code>, etc.)</li>\n<li><code>beforeFiles</code> (<code>rewrites</code> ) from <code>next.config.js</code></li>\n<li>Filesystem routes (<code>public/</code>, <code>_next/static/</code>, <code>pages/</code>, <code>app/</code>, etc.)</li>\n<li><code>afterFiles</code> (<code>rewrites</code> ) from <code>next.config.js</code></li>\n<li>Dynamic Routes (<code>/blog/[slug]</code>)</li>\n<li><code>fallback</code> (<code>rewrite</code> ) from <code>next.config.js</code></li>\n</ol>\n<p>There are two wats to define which paths Middleware will run on:</p>\n<ol>\n<li>Custom matcher config</li>\n<li>Conditional statements</li>\n</ol>\n<h3>Matcher</h3>\n<p><code>matcher</code> allows you to filter Middleware to run on specific paths.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> config = {\n\tmatcher : <span class=\"hljs-string\">\"/about/:path\"</span>\n}</code></pre>\n<p>You can match a single path or multiple paths with an array syntax:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> config = {\n  <span class=\"hljs-attr\">matcher</span>: [<span class=\"hljs-string\">'/about/:path*'</span>, <span class=\"hljs-string\">'/dashboard/:path*'</span>],\n};</code></pre>\n<p>The <code>matcher</code> config allows you full regex so matching like negative lookaheads or character matching is supported. The regex must be enclosed within the parenthesis.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> config = {\n  <span class=\"hljs-attr\">matcher</span>: [\n    <span class=\"hljs-comment\">/*\n     * Match all request paths except for the ones starting with:\n     * - api (API routes)\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */</span>\n    <span class=\"hljs-string\">'/((?!api|_next/static|_next/image|favicon.ico).*)'</span>,\n  ],\n};</code></pre>\n<p>Configured matches:</p>\n<ol>\n<li>MUST start with <code>/</code></li>\n<li>Can include named parameters: <code>/about/:path</code> matches <code>/about/a</code> and <code>/about/b</code> but not <code>/about/a/c</code></li>\n<li>Can have modifiers on named parameters (starting with <code>:</code>): <code>/about/:path*</code> matches <code>/about/a/b/c</code> because <code>*</code> is <em>zero or more</em>. <code>?</code> is <em>zero or one</em> and <code>+</code> <em>one or more</em></li>\n<li>Can use regular expression enclosed in parenthesis: <code>/about/(.*)</code> is the same as <code>/about/:path*</code></li>\n</ol>\n<h3>Conditional Statements</h3>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">NextResponse</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/server'</span>;\n \n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">middleware</span>(<span class=\"hljs-params\">request</span>) {\n  <span class=\"hljs-keyword\">if</span> (request.<span class=\"hljs-property\">nextUrl</span>.<span class=\"hljs-property\">pathname</span>.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">'/about'</span>)) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">rewrite</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(<span class=\"hljs-string\">'/about-2'</span>, request.<span class=\"hljs-property\">url</span>));\n  }\n \n  <span class=\"hljs-keyword\">if</span> (request.<span class=\"hljs-property\">nextUrl</span>.<span class=\"hljs-property\">pathname</span>.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">'/dashboard'</span>)) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">rewrite</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(<span class=\"hljs-string\">'/dashboard/user'</span>, request.<span class=\"hljs-property\">url</span>));\n  }\n}</code></pre>\n<h3>NextResponse</h3>\n<p>The <code>NextResponse</code> API allows you to:</p>\n<ul>\n<li><code>redirect</code> the incoming request to a different URL</li>\n<li><code>rewrite</code> the response by displaying a given URL</li>\n<li>Set request headers for API Routes, <code>getServerSideProps</code>, and <code>rewrite</code> destinations</li>\n<li>Set response cookies</li>\n<li>Set response headers</li>\n</ul>\n<p>To produce a response from Middleware, you can:</p>\n<ol>\n<li><code>rewrite</code> to a route (<a href=\"https://nextjs.org/docs/pages/building-your-application/routing/pages-and-layouts\">Page</a> or <a href=\"https://nextjs.org/docs/pages/building-your-application/routing/api-routes\">Edge API Route</a>) that produces a response</li>\n<li>return a <code>NextResponse</code> directly. See <a href=\"https://nextjs.org/docs/pages/building-your-application/routing/middleware#producing-a-response\">Producing a Response</a></li>\n</ol>\n<h2>Using Cookies</h2>\n<p>Cookies are regular headers. On a <code>Request</code>, they are stored in the <code>Cookie</code> header. On a <code>Response</code> they are in the <code>Set-Cookie</code> header. Next.js provides a convenient way to access and manipulate these cookies through the <code>cookies</code> extension on <code>NextRequest</code> and <code>NextResponse</code></p>\n<ol>\n<li>For income requests, <code>cookies</code> comes with the following methods: <code>get</code>, <code>getAll</code>, <code>set</code> , and <code>delete</code> cookies. You can check for existence of a cookie with <code>has</code> or remove all cookies with <code>clear</code></li>\n<li>For outgoing responses, <code>cookies</code> have the following methods: <code>get</code>, <code>getAll</code>, <code>set</code>, and <code>delete</code>.</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {<span class=\"hljs-title class_\">NextResponse</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"next/server\"</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">middleware</span>(<span class=\"hljs-params\">request</span>) {\n\t<span class=\"hljs-keyword\">let</span> cookie = request.<span class=\"hljs-property\">cookies</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"nextjs\"</span>)?.<span class=\"hljs-property\">value</span>\n\t<span class=\"hljs-keyword\">const</span> allCookies = request.<span class=\"hljs-property\">cookies</span>.<span class=\"hljs-title function_\">getAll</span>()\n\trequest.<span class=\"hljs-property\">cookies</span>.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">\"nextjs\"</span>)\n\trequest.<span class=\"hljs-property\">cookies</span>.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">\"nextjs\"</span>)\n\n\t<span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">next</span>()\n\tresponse.<span class=\"hljs-property\">cookies</span>.<span class=\"hljs-title function_\">set</span>({\n\t\tname : <span class=\"hljs-string\">\"Vercel\"</span>,\n\t\tvalue : <span class=\"hljs-string\">\"fast\"</span>\n\t})\n\tcookie = response.<span class=\"hljs-property\">cookies</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">\"vercel\"</span>)\n\t<span class=\"hljs-keyword\">return</span> response\n}</code></pre>\n<h2>Setting Headers</h2>\n<p>You can set request and response headers using the <code>NextResponse</code> API (setting <em>request</em> headers is available since Next.js v13.0.0).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">NextResponse</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/server'</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">middleware</span>(<span class=\"hljs-params\">request</span>) {\n  <span class=\"hljs-comment\">// Clone the request headers and set a new header `x-hello-from-middleware1`</span>\n  <span class=\"hljs-keyword\">const</span> requestHeaders = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Headers</span>(request.<span class=\"hljs-property\">headers</span>);\n  requestHeaders.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">'x-hello-from-middleware1'</span>, <span class=\"hljs-string\">'hello'</span>);\n \n  <span class=\"hljs-comment\">// You can also set request headers in NextResponse.rewrite</span>\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-title class_\">NextResponse</span>.<span class=\"hljs-title function_\">next</span>({\n    <span class=\"hljs-attr\">request</span>: {\n      <span class=\"hljs-comment\">// New request headers</span>\n      <span class=\"hljs-attr\">headers</span>: requestHeaders,\n    },\n  });\n \n  <span class=\"hljs-comment\">// Set a new response header `x-hello-from-middleware2`</span>\n  response.<span class=\"hljs-property\">headers</span>.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">'x-hello-from-middleware2'</span>, <span class=\"hljs-string\">'hello'</span>);\n  <span class=\"hljs-keyword\">return</span> response;\n}</code></pre>\n<h3>Producing a Response</h3>\n<p>You can respond from Middleware directly by returning a <code>Response</code> or <code>NextResponse</code> instance. (This is available since <a href=\"https://nextjs.org/blog/next-13-1#nextjs-advanced-middleware\">Next.js v13.1.0</a>)</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">NextResponse</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'next/server'</span>;\n<span class=\"hljs-keyword\">import</span> { isAuthenticated } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@lib/auth'</span>;\n \n<span class=\"hljs-comment\">// Limit the middleware to paths starting with `/api/`</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> config = {\n  <span class=\"hljs-attr\">matcher</span>: <span class=\"hljs-string\">'/api/:function*'</span>,\n};\n \n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">middleware</span>(<span class=\"hljs-params\">request</span>) {\n  <span class=\"hljs-comment\">// Call our authentication function to check the request</span>\n  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title function_\">isAuthenticated</span>(request)) {\n    <span class=\"hljs-comment\">// Respond with JSON indicating an error message</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NextResponse</span>(\n      <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>({ <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'authentication failed'</span> }),\n      { <span class=\"hljs-attr\">status</span>: <span class=\"hljs-number\">401</span>, <span class=\"hljs-attr\">headers</span>: { <span class=\"hljs-string\">'content-type'</span>: <span class=\"hljs-string\">'application/json'</span> } },\n    );\n  }\n}</code></pre>\n"}]
        }
        export default data;
    